--- bin/ksh/.patch	1970-01-01 01:00:00 +0100
+++ bin/ksh/.patch	2025-09-12 11:34:13 +0200
@@ -0,0 +1 @@
+This directory has been patched.
--- bin/ksh/debug.c	1970-01-01 01:00:00 +0100
+++ bin/ksh/debug.c	2025-09-14 04:22:38 +0200
@@ -0,0 +1,131 @@
+#include <stdio.h>
+
+#include "sh.h"
+
+const char const* __E_TYPE[] = {
+	"E_NONE",
+	"E_PARSE",
+	"E_FUNC",
+	"E_INCL",
+	"E_EXEC",
+	"E_LOOP",
+	"E_ERRH"
+};
+const char const* __STATE[] = {
+	"PRUNNING",
+	"PEXITED",
+	"PSIGNALLED",
+	"PSTOPPED"
+};
+const char const* __L_TYPE[] = {
+	"LNONE",
+	"LRETURN",
+	"LEXIT",
+	"LERROR",
+	"LLEAVE",
+	"LINTR",
+	"LBREAK",
+	"LCONTIN",
+	"LSHELL",
+	"LAEXPR"
+};
+const char const* __T_TYPE[] = {
+	"TEOF",
+	"TCOM",
+	"TPAREN",
+	"TPIPE",
+	"TLIST",
+	"TOR",
+	"TAND",
+	"TBANG",
+	"TDBRACKET",
+	"TFOR",
+	"TSELECT",
+	"TCASE",
+	"TIF",
+	"TWHILE",
+	"TUNTIL",
+	"TELIF",
+	"TPAT",
+	"TBRACE",
+	"TASYNC",
+	"TFUNCT",
+	"TTIME",
+	"TEXEC",
+	"TCOPROC"
+};
+const char const* __C_TYPE[] = {
+	"CNONE",
+	"CSHELL",
+	"CFUNC",
+	"XXXXXX",
+	"CEXEC",
+	"CALIAS",
+	"CKEYWD",
+	"CTALIAS"
+};
+const char const* __X_TYPE[] = {
+	"XBASE",
+	"XSUB",
+	"XARGSEP",
+	"XARG",
+	"XCOM",
+	"XNULLSUB",
+	"XSUBMID"
+};
+
+char __X_BUF[255];
+
+char *
+__X_FLAGS(int flags)
+{
+	char *buf = __X_BUF;
+
+	*buf = 0;
+	if (flags & XEXEC)
+		buf += sprintf(buf, "[XEXEC]");
+	if (flags & XFORK)
+		buf += sprintf(buf, "[XFORK]");
+	if (flags & XBGND)
+		buf += sprintf(buf, "[XBGND]");
+	if (flags & XPIPEI)
+		buf += sprintf(buf, "[XPIPEI]");
+	if (flags & XPIPEO)
+		buf += sprintf(buf, "[XPIPEO]");
+	if (flags & XXCOM)
+		buf += sprintf(buf, "[XXCOM]");
+	if (flags & XPCLOSE)
+		buf += sprintf(buf, "[XPCLOSE]");
+	if (flags & XCCLOSE)
+		buf += sprintf(buf, "[XCCLOSE]");
+	if (flags & XERROK)
+		buf += sprintf(buf, "[XERROK]");
+	if (flags & XCOPROC)
+		buf += sprintf(buf, "[XCOPROC]");
+	if (flags & XTIME)
+		buf += sprintf(buf, "[XTIME]");
+	return(__X_BUF);
+}
+
+/* Flags for j_waitj() */
+#define JW_NONE		0x00
+#define JW_INTERRUPT	0x01	/* ^C will stop the wait */
+#define JW_ASYNCNOTIFY	0x02	/* asynchronous notification during wait ok */
+#define JW_STOPPEDWAIT	0x04	/* wait even if job stopped */
+
+char __JW_BUF[255];
+
+char *
+__JW_FLAGS(int flags)
+{
+	char *buf = __JW_BUF;
+
+	*buf = 0;
+	if (flags & JW_INTERRUPT)
+		buf += sprintf(buf, "[JW_INTERRUPT]");
+	if (flags & JW_ASYNCNOTIFY)
+		buf += sprintf(buf, "[JW_ASYNCNOTIFY]");
+	if (flags & JW_STOPPEDWAIT)
+		buf += sprintf(buf, "[JW_STOPPEDWAIT]");
+	return(__JW_BUF);
+}
--- bin/ksh/debug.h	1970-01-01 01:00:00 +0100
+++ bin/ksh/debug.h	2025-09-14 04:26:52 +0200
@@ -0,0 +1,37 @@
+int msvc_printf(const char *format, ...);
+
+#define __PRINTF(...)	msvc_printf("[" __FILE__ "]\t" __VA_ARGS__);
+
+#ifdef DEBUG_SUBST
+#define __DEBUG_SUBST(...)	__PRINTF(" " __VA_ARGS__)
+#else
+#define __DEBUG_SUBST(...)
+#endif
+
+#ifdef DEBUG_JOBS
+#define __DEBUG_JOBS(...)	__PRINTF(" " __VA_ARGS__)
+#else
+#define __DEBUG_JOBS(...)
+#endif
+
+#ifdef DEBUG_EXIT
+#define __DEBUG_EXIT(...)	__PRINTF(" " __VA_ARGS__)
+#else
+#define __DEBUG_EXIT(...)
+#endif
+
+#ifdef DEBUG
+#define __DEBUG(...)		__PRINTF(__VA_ARGS__)
+#else
+#define __DEBUG(...)
+#endif
+
+extern const char const* __E_TYPE[];
+extern const char const* __STATE[];
+extern const char const* __L_TYPE[];
+extern const char const* __T_TYPE[];
+extern const char const* __C_TYPE[];
+extern const char const* __X_TYPE[];
+
+char *__X_FLAGS(int flags);
+char *__JW_FLAGS(int flags);
--- bin/ksh/edit.h	2014-05-19 17:05:13 +0200
+++ bin/ksh/edit.h	2025-09-14 04:26:52 +0200
@@ -35,7 +35,7 @@
 	int eof;
 } X_chars;
 
-EXTERN X_chars edchars;
+EXTERN __thread X_chars edchars;
 
 /* x_cf_glob() flags */
 #define XCF_COMMAND	BIT(0)	/* Do command completion */
--- bin/ksh/emacs.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/emacs.c	2022-01-15 08:10:01 +0100
@@ -1,4 +1,4 @@
-/*	$OpenBSD: src/bin/ksh/emacs.c,v 1.48 2013/12/17 16:37:05 deraadt Exp $	*/
+/*	$OpenBSD: emacs.c,v 1.89 2021/10/09 21:38:00 halex Exp $	*/
 
 /*
  *  Emacs-like command line editing and history
@@ -14,29 +14,37 @@
 #include "config.h"
 #ifdef EMACS
 
-#include "sh.h"
-#include <sys/stat.h>
 #include <sys/queue.h>
+#include <sys/stat.h>
+
 #include <ctype.h>
-#include <locale.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#ifndef SMALL
+# include <term.h>
+# include <curses.h>
+#endif
+
+#include "sh.h"
 #include "edit.h"
 
 static	Area	aedit;
 #define	AEDIT	&aedit		/* area for kill ring and macro defns */
 
+#undef CTRL
 #define	CTRL(x)		((x) == '?' ? 0x7F : (x) & 0x1F)	/* ASCII */
 #define	UNCTRL(x)	((x) == 0x7F ? '?' : (x) | 0x40)	/* ASCII */
-#define	META(x)		((x) & 0x7f)
-#define	ISMETA(x)	(Flag(FEMACSUSEMETA) && ((x) & 0x80))
-
 
 /* values returned by keyboard functions */
 #define	KSTD	0
 #define	KEOL	1		/* ^M, ^J */
 #define	KINTR	2		/* ^G, ^C */
 
+typedef int (*kb_func)(int);
+
 struct	x_ftab {
-	int		(*xf_func)(int c);
+	kb_func		xf_func;
 	const char	*xf_name;
 	short		xf_flags;
 };
@@ -49,7 +57,8 @@
 #define	is_cfs(c)	(c == ' ' || c == '\t' || c == '"' || c == '\'')
 
 /* Separator for motion */
-#define	is_mfs(c)	(!(isalnum((unsigned char)c) || c == '_' || c == '$'))
+#define	is_mfs(c)	(!(isalnum((unsigned char)c) || \
+			c == '_' || c == '$' || c & 0x80))
 
 /* Arguments for do_complete()
  * 0 = enumerate  M-= complete as much as possible and then list
@@ -82,7 +91,7 @@
 static char    *xcp;		/* current position */
 static char    *xep;		/* current end */
 static char    *xbp;		/* start of visible portion of input buffer */
-static char    *xlp;		/* last char visible on screen */
+static char    *xlp;		/* last byte visible on screen */
 static int	x_adj_ok;
 /*
  * we use x_adj_done so that functions can tell
@@ -132,17 +141,19 @@
 static void	x_adjust(void);
 static void	x_e_ungetc(int);
 static int	x_e_getc(void);
+static int	x_e_getu8(char *, int);
 static void	x_e_putc(int);
 static void	x_e_puts(const char *);
 static int	x_comment(int);
 static int	x_fold_case(int);
 static char	*x_lastcp(void);
 static void	do_complete(int, Comp_type);
-static int	x_emacs_putbuf(const char *, size_t);
+static int	isu8cont(unsigned char);
 
 /* proto's for keybindings */
 static int	x_abort(int);
 static int	x_beg_hist(int);
+static int	x_clear_screen(int);
 static int	x_comp_comm(int);
 static int	x_comp_file(int);
 static int	x_complete(int);
@@ -182,10 +193,7 @@
 static int	x_search_char_back(int);
 static int	x_search_hist(int);
 static int	x_set_mark(int);
-static int	x_stuff(int);
-static int	x_stuffreset(int);
 static int	x_transpose(int);
-static int	x_version(int);
 static int	x_xchg_point_mark(int);
 static int	x_yank(int);
 static int	x_comp_list(int);
@@ -202,6 +210,7 @@
 static const struct x_ftab x_ftab[] = {
 	{ x_abort,		"abort",			0 },
 	{ x_beg_hist,		"beginning-of-history",		0 },
+	{ x_clear_screen,	"clear-screen",			0 },
 	{ x_comp_comm,		"complete-command",		0 },
 	{ x_comp_file,		"complete-file",		0 },
 	{ x_complete,		"complete",			0 },
@@ -241,10 +250,7 @@
 	{ x_search_char_back,	"search-character-backward",	XF_ARG },
 	{ x_search_hist,	"search-history",		0 },
 	{ x_set_mark,		"set-mark-command",		0 },
-	{ x_stuff,		"stuff",			0 },
-	{ x_stuffreset,		"stuff-reset",			0 },
 	{ x_transpose,		"transpose-chars",		0 },
-	{ x_version,		"version",			0 },
 	{ x_xchg_point_mark,	"exchange-point-and-mark",	0 },
 	{ x_yank,		"yank",				0 },
 	{ x_comp_list,		"complete-list",		0 },
@@ -264,11 +270,17 @@
 };
 
 int
+isu8cont(unsigned char c)
+{
+	return (c & (0x80 | 0x40)) == 0x80;
+}
+
+int
 x_emacs(char *buf, size_t len)
 {
 	struct kb_entry		*k, *kmatch = NULL;
 	char			line[LINE + 1];
-	int			at = 0, submatch, ret, c;
+	int			at = 0, ntries = 0, submatch, ret;
 	const char		*p;
 
 	xbp = xbuf = buf; xend = buf + len;
@@ -303,17 +315,14 @@
 		x_nextcmd = -1;
 	}
 
-	line[0] = '\0';
 	x_literal_set = 0;
 	x_arg = -1;
 	x_last_command = NULL;
 	while (1) {
 		x_flush();
-		if ((c = x_e_getc()) < 0)
+		if ((at = x_e_getu8(line, at)) < 0)
 			return 0;
-
-		line[at++] = c;
-		line[at] = '\0';
+		ntries++;
 
 		if (x_arg == -1) {
 			x_arg = 1;
@@ -331,7 +340,7 @@
 				if (at > k->len)
 					continue;
 
-				if (!bcmp(k->seq, line, at)) {
+				if (memcmp(k->seq, line, at) == 0) {
 					/* sub match */
 					submatch++;
 					if (k->len == at)
@@ -351,14 +360,18 @@
 				macro_args = kmatch->args;
 				ret = KSTD;
 			} else
-				ret = kmatch->ftab->xf_func(c);
+				ret = kmatch->ftab->xf_func(line[at - 1]);
 		} else {
 			if (submatch)
 				continue;
-			if (at == 1)
-				ret = x_insert(c);
-			else
-				ret = x_error(c); /* not matched meta sequence */
+			if (ntries > 1) {
+				ret = x_error(0); /* unmatched meta sequence */
+			} else if (at > 1) {
+				x_ins(line);
+				ret = KSTD;
+			} else {
+				ret = x_insert(line[0]);
+			}
 		}
 
 		switch (ret) {
@@ -383,8 +396,7 @@
 		}
 
 		/* reset meta sequence */
-		at = 0;
-		line[0] = '\0';
+		at = ntries = 0;
 		if (x_arg_set)
 			x_arg_set = 0; /* reset args next time around */
 		else
@@ -417,10 +429,8 @@
 	return x_insert(c);
 }
 
-static int x_do_ins(const char *cp, int len);
-
 static int
-x_do_ins(const char *cp, int len)
+x_do_ins(const char *cp, size_t len)
 {
 	if (xep+len >= xend) {
 		x_e_putc(BEL);
@@ -460,19 +470,6 @@
 	return 0;
 }
 
-/*
- * this is used for x_escape() in do_complete()
- */
-static int
-x_emacs_putbuf(const char *s, size_t len)
-{
-	int rval;
-
-	if ((rval = x_do_ins(s, len)) != 0)
-		return (rval);
-	return (rval);
-}
-
 static int
 x_del_back(int c)
 {
@@ -484,6 +481,8 @@
 	}
 	if (x_arg > col)
 		x_arg = col;
+	while (x_arg < col && isu8cont(xcp[-x_arg]))
+		x_arg++;
 	x_goto(xcp - x_arg);
 	x_delete(x_arg, false);
 	return KSTD;
@@ -500,11 +499,13 @@
 	}
 	if (x_arg > nleft)
 		x_arg = nleft;
+	while (x_arg < nleft && isu8cont(xcp[x_arg]))
+		x_arg++;
 	x_delete(x_arg, false);
 	return KSTD;
 }
 
-/* Delete nc chars to the right of the cursor (including cursor position) */
+/* Delete nc bytes to the right of the cursor (including cursor position) */
 static void
 x_delete(int nc, int push)
 {
@@ -535,6 +536,7 @@
 	}
 	memmove(xcp, xcp+nc, xep - xcp + 1);	/* Copies the null */
 	x_adj_ok = 0;			/* don't redraw */
+	xlp_valid = false;
 	x_zots(xcp);
 	/*
 	 * if we are already filling the line,
@@ -676,6 +678,8 @@
 		return 4;	/* Kludge, tabs are always four spaces. */
 	if (iscntrl(c))		/* control char */
 		return 2;
+	if (isu8cont(c))
+		return 0;
 	return 1;
 }
 
@@ -684,6 +688,11 @@
 {
 	int	adj = x_adj_done;
 
+	if (str > xbuf && isu8cont(*str)) {
+		while (str > xbuf && isu8cont(*str))
+			str--;
+		x_e_putc('\b');
+	}
 	x_lastcp();
 	while (*str && str < xlp && adj == x_adj_done)
 		x_zotc(*str++);
@@ -713,6 +722,8 @@
 	}
 	if (x_arg > col)
 		x_arg = col;
+	while (x_arg < col && isu8cont(xcp[-x_arg]))
+		x_arg++;
 	x_goto(xcp - x_arg);
 	return KSTD;
 }
@@ -728,6 +739,8 @@
 	}
 	if (x_arg > nleft)
 		x_arg = nleft;
+	while (x_arg < nleft && isu8cont(xcp[x_arg]))
+		x_arg++;
 	x_goto(xcp + x_arg);
 	return KSTD;
 }
@@ -850,7 +863,7 @@
 		return (x_del_char(c));
 }
 
-static void *
+static kb_func
 kb_find_hist_func(char c)
 {
 	struct kb_entry		*k;
@@ -884,9 +897,10 @@
 		if ((c = x_e_getc()) < 0)
 			return KSTD;
 		f = kb_find_hist_func(c);
-		if (c == CTRL('['))
+		if (c == CTRL('[') || c == CTRL('@')) {
+			x_e_ungetc(c);
 			break;
-		else if (f == x_search_hist)
+		} else if (f == x_search_hist)
 			offset = x_search(pat, 0, offset);
 		else if (f == x_del_back) {
 			if (p == pat) {
@@ -999,12 +1013,19 @@
 {
 	x_redraw(-1);
 	return KSTD;
+}
 
+static int
+x_clear_screen(int c)
+{
+	x_redraw(-2);
+	return KSTD;
 }
 
-/* Redraw (part of) the line.  If limit is < 0, the everything is redrawn
- * on a NEW line, otherwise limit is the screen column up to which needs
- * redrawing.
+/* Redraw (part of) the line.
+ * A non-negative limit is the screen column up to which needs
+ * redrawing. A limit of -1 redraws on a new line, while a limit
+ * of -2 (attempts to) clear the screen.
  */
 static void
 x_redraw(int limit)
@@ -1013,13 +1034,24 @@
 	char	*cp;
 
 	x_adj_ok = 0;
-	if (limit == -1)
+	if (limit == -2) {
+		int cleared = 0;
+#ifndef SMALL
+		if (cur_term != NULL && clear_screen != NULL) {
+			if (tputs(clear_screen, 1, x_putc) != ERR)
+				cleared = 1;
+		}
+#endif
+		if (!cleared)
+			x_e_putc('\n');
+	}
+	else if (limit == -1)
 		x_e_putc('\n');
-	else
+	else if (limit >= 0)
 		x_e_putc('\r');
 	x_flush();
 	if (xbp == xbuf) {
-		x_col = promptlen(prompt, (const char **) 0);
+		x_col = promptlen(prompt, NULL);
 		if (x_col > xx_cols)
 			truncate = (x_col / xx_cols) * xx_cols;
 		if (prompt_redraw)
@@ -1033,7 +1065,7 @@
 		x_displen = xx_cols - 2;
 	}
 	xlp_valid = false;
-	cp = x_lastcp();
+	x_lastcp();
 	x_zots(xbp);
 	if (xbp != xbuf || xep > xlp)
 		limit = xx_cols;
@@ -1061,7 +1093,9 @@
 	for (cp = xlp; cp > xcp; )
 		x_bs(*--cp);
 	x_adj_ok = 1;
-	D__(x_flush();)
+#ifdef DEBUG
+	x_flush();
+#endif
 	return;
 }
 
@@ -1135,6 +1169,8 @@
 		x_arg = lastcol;
 	else if (x_arg > lastcol)
 		x_arg = lastcol;
+	while (x_arg < lastcol && isu8cont(xbuf[x_arg]))
+		x_arg++;
 	ndel = x_arg - col;
 	if (ndel < 0) {
 		x_goto(xbuf + x_arg);
@@ -1148,8 +1184,7 @@
 x_push(int nchars)
 {
 	char	*cp = str_nsave(xcp, nchars, AEDIT);
-	if (killstack[killsp])
-		afree((void *)killstack[killsp], AEDIT);
+	afree(killstack[killsp], AEDIT);
 	killstack[killsp] = cp;
 	killsp = (killsp + 1) % KILLSIZE;
 }
@@ -1213,36 +1248,6 @@
 	return KSTD;
 }
 
-static int
-x_stuffreset(int c)
-{
-#ifdef TIOCSTI
-	(void)x_stuff(c);
-	return KINTR;
-#else
-	x_zotc(c);
-	xlp = xcp = xep = xbp = xbuf;
-	xlp_valid = true;
-	*xcp = 0;
-	x_redraw(-1);
-	return KSTD;
-#endif
-}
-
-static int
-x_stuff(int c)
-{
-#ifdef TIOCSTI
-	char	ch = c;
-	bool	savmode = x_mode(false);
-
-	(void)ioctl(TTY, TIOCSTI, &ch);
-	(void)x_mode(savmode);
-	x_redraw(-1);
-#endif
-	return KSTD;
-}
-
 static char *
 kb_encode(const char *s)
 {
@@ -1271,11 +1276,11 @@
 kb_decode(const char *s)
 {
 	static char		l[LINE + 1];
-	int			i, at = 0;
+	unsigned int		i, at = 0;
 
 	l[0] = '\0';
 	for (i = 0; i < strlen(s); i++) {
-		if (iscntrl(s[i])) {
+		if (iscntrl((unsigned char)s[i])) {
 			l[at++] = '^';
 			l[at++] = UNCTRL(s[i]);
 		} else
@@ -1296,7 +1301,7 @@
 		if (len > k->len)
 			continue;
 
-		if (!bcmp(k->seq, s, len))
+		if (memcmp(k->seq, s, len) == 0)
 			return (1);
 	}
 
@@ -1307,21 +1312,20 @@
 kb_del(struct kb_entry *k)
 {
 	TAILQ_REMOVE(&kblist, k, entry);
-	if (k->args)
-		free(k->args);
+	free(k->args);
 	afree(k, AEDIT);
 }
 
 static struct kb_entry *
-kb_add_string(void *func, void *args, char *str)
+kb_add_string(kb_func func, void *args, char *str)
 {
-	int			i, count;
+	unsigned int		ele, count;
 	struct kb_entry		*k;
 	struct x_ftab		*xf = NULL;
 
-	for (i = 0; i < NELEM(x_ftab); i++)
-		if (x_ftab[i].xf_func == func) {
-			xf = (struct x_ftab *)&x_ftab[i];
+	for (ele = 0; ele < NELEM(x_ftab); ele++)
+		if (x_ftab[ele].xf_func == func) {
+			xf = (struct x_ftab *)&x_ftab[ele];
 			break;
 		}
 	if (xf == NULL)
@@ -1348,24 +1352,24 @@
 }
 
 static struct kb_entry *
-kb_add(void *func, void *args, ...)
+kb_add(kb_func func, ...)
 {
 	va_list			ap;
-	int			i, count;
-	char			l[LINE + 1];
-
-	va_start(ap, args);
-	count = 0;
-	while (va_arg(ap, unsigned int) != 0)
-		count++;
-	va_end(ap);
+	unsigned char		ch;
+	unsigned int		i;
+	char			line[LINE + 1];
 
-	va_start(ap, args);
-	for (i = 0; i <= count /* <= is correct */; i++)
-		l[i] = (unsigned char)va_arg(ap, unsigned int);
+	va_start(ap, func);
+	for (i = 0; i < sizeof(line) - 1; i++) {
+		ch = va_arg(ap, unsigned int);
+		if (ch == 0)
+			break;
+		line[i] = ch;
+	}
 	va_end(ap);
+	line[i] = '\0';
 
-	return (kb_add_string(func, args, l));
+	return (kb_add_string(func, NULL, line));
 }
 
 static void
@@ -1385,7 +1389,7 @@
 	int macro,		/* bind -m */
 	int list)		/* bind -l */
 {
-	int			i;
+	unsigned int		i;
 	struct kb_entry		*k, *kb;
 	char			in[LINE + 1];
 
@@ -1469,128 +1473,116 @@
 void
 x_init_emacs(void)
 {
-	char *locale;
-
 	x_tty = 1;
 	ainit(AEDIT);
 	x_nextcmd = -1;
 
-	/* Determine if we can translate meta key or use 8-bit AscII
-	 * XXX - It would be nice if there was a locale attribute to
-	 * determine if the locale is 7-bit or not.
-	 */
-	locale = setlocale(LC_CTYPE, NULL);
-	if (locale == NULL || !strcmp(locale, "C") || !strcmp(locale, "POSIX"))
-		Flag(FEMACSUSEMETA) = 1;
-
-	/* new keybinding stuff */
 	TAILQ_INIT(&kblist);
 
 	/* man page order */
-	kb_add(x_abort,			NULL, CTRL('G'), 0);
-	kb_add(x_mv_back,		NULL, CTRL('B'), 0);
-	kb_add(x_mv_back,		NULL, CTRL('X'), CTRL('D'), 0);
-	kb_add(x_mv_bword,		NULL, CTRL('['), 'b', 0);
-	kb_add(x_beg_hist,		NULL, CTRL('['), '<', 0);
-	kb_add(x_mv_begin,		NULL, CTRL('A'), 0);
-	kb_add(x_fold_capitalize,	NULL, CTRL('['), 'C', 0);
-	kb_add(x_fold_capitalize,	NULL, CTRL('['), 'c', 0);
-	kb_add(x_comment,		NULL, CTRL('['), '#', 0);
-	kb_add(x_complete,		NULL, CTRL('['), CTRL('['), 0);
-	kb_add(x_comp_comm,		NULL, CTRL('X'), CTRL('['), 0);
-	kb_add(x_comp_file,		NULL, CTRL('['), CTRL('X'), 0);
-	kb_add(x_comp_list,		NULL, CTRL('I'), 0);
-	kb_add(x_comp_list,		NULL, CTRL('['), '=', 0);
-	kb_add(x_del_back,		NULL, CTRL('?'), 0);
-	kb_add(x_del_back,		NULL, CTRL('H'), 0);
-	/* x_del_char not assigned by default */
-	kb_add(x_del_bword,		NULL, CTRL('['), CTRL('?'), 0);
-	kb_add(x_del_bword,		NULL, CTRL('['), CTRL('H'), 0);
-	kb_add(x_del_bword,		NULL, CTRL('['), 'h', 0);
-	kb_add(x_del_fword,		NULL, CTRL('['), 'd', 0);
-	kb_add(x_next_com,		NULL, CTRL('N'), 0);
-	kb_add(x_next_com,		NULL, CTRL('X'), 'B', 0);
-	kb_add(x_fold_lower,		NULL, CTRL('['), 'L', 0);
-	kb_add(x_fold_lower,		NULL, CTRL('['), 'l', 0);
-	kb_add(x_end_hist,		NULL, CTRL('['), '>', 0);
-	kb_add(x_mv_end,		NULL, CTRL('E'), 0);
+	kb_add(x_abort,			CTRL('G'), 0);
+	kb_add(x_mv_back,		CTRL('B'), 0);
+	kb_add(x_mv_back,		CTRL('X'), CTRL('D'), 0);
+	kb_add(x_mv_bword,		CTRL('['), 'b', 0);
+	kb_add(x_beg_hist,		CTRL('['), '<', 0);
+	kb_add(x_mv_begin,		CTRL('A'), 0);
+	kb_add(x_fold_capitalize,	CTRL('['), 'C', 0);
+	kb_add(x_fold_capitalize,	CTRL('['), 'c', 0);
+	kb_add(x_comment,		CTRL('['), '#', 0);
+	kb_add(x_complete,		CTRL('['), CTRL('['), 0);
+	kb_add(x_comp_comm,		CTRL('X'), CTRL('['), 0);
+	kb_add(x_comp_file,		CTRL('['), CTRL('X'), 0);
+	kb_add(x_comp_list,		CTRL('I'), 0);
+	kb_add(x_comp_list,		CTRL('['), '=', 0);
+	kb_add(x_del_back,		CTRL('?'), 0);
+	kb_add(x_del_back,		CTRL('H'), 0);
+	kb_add(x_del_char,		CTRL('['), '[', '3', '~', 0); /* delete */
+	kb_add(x_del_bword,		CTRL('W'), 0);
+	kb_add(x_del_bword,		CTRL('['), CTRL('?'), 0);
+	kb_add(x_del_bword,		CTRL('['), CTRL('H'), 0);
+	kb_add(x_del_bword,		CTRL('['), 'h', 0);
+	kb_add(x_del_fword,		CTRL('['), 'd', 0);
+	kb_add(x_next_com,		CTRL('N'), 0);
+	kb_add(x_next_com,		CTRL('X'), 'B', 0);
+	kb_add(x_fold_lower,		CTRL('['), 'L', 0);
+	kb_add(x_fold_lower,		CTRL('['), 'l', 0);
+	kb_add(x_end_hist,		CTRL('['), '>', 0);
+	kb_add(x_mv_end,		CTRL('E'), 0);
 	/* how to handle: eot: ^_, underneath copied from original keybindings */
-	kb_add(x_end_of_text,		NULL, CTRL('_'), 0);
-	kb_add(x_eot_del,		NULL, CTRL('D'), 0);
+	kb_add(x_end_of_text,		CTRL('_'), 0);
+	kb_add(x_eot_del,		CTRL('D'), 0);
 	/* error */
-	kb_add(x_xchg_point_mark,	NULL, CTRL('X'), CTRL('X'), 0);
-	kb_add(x_expand,		NULL, CTRL('['), '*', 0);
-	kb_add(x_mv_forw,		NULL, CTRL('F'), 0);
-	kb_add(x_mv_forw,		NULL, CTRL('X'), 'C', 0);
-	kb_add(x_mv_fword,		NULL, CTRL('['), 'f', 0);
-	kb_add(x_goto_hist,		NULL, CTRL('['), 'g', 0);
+	kb_add(x_xchg_point_mark,	CTRL('X'), CTRL('X'), 0);
+	kb_add(x_expand,		CTRL('['), '*', 0);
+	kb_add(x_mv_forw,		CTRL('F'), 0);
+	kb_add(x_mv_forw,		CTRL('X'), 'C', 0);
+	kb_add(x_mv_fword,		CTRL('['), 'f', 0);
+	kb_add(x_goto_hist,		CTRL('['), 'g', 0);
 	/* kill-line */
-	kb_add(x_del_bword,		NULL, CTRL('W'), 0); /* not what man says */
-	kb_add(x_kill,			NULL, CTRL('K'), 0);
-	kb_add(x_enumerate,		NULL, CTRL('['), '?', 0);
-	kb_add(x_list_comm,		NULL, CTRL('X'), '?', 0);
-	kb_add(x_list_file,		NULL, CTRL('X'), CTRL('Y'), 0);
-	kb_add(x_newline,		NULL, CTRL('J'), 0);
-	kb_add(x_newline,		NULL, CTRL('M'), 0);
-	kb_add(x_nl_next_com,		NULL, CTRL('O'), 0);
+	kb_add(x_kill,			CTRL('K'), 0);
+	kb_add(x_enumerate,		CTRL('['), '?', 0);
+	kb_add(x_list_comm,		CTRL('X'), '?', 0);
+	kb_add(x_list_file,		CTRL('X'), CTRL('Y'), 0);
+	kb_add(x_newline,		CTRL('J'), 0);
+	kb_add(x_newline,		CTRL('M'), 0);
+	kb_add(x_nl_next_com,		CTRL('O'), 0);
 	/* no-op */
-	kb_add(x_prev_histword,		NULL, CTRL('['), '.', 0);
-	kb_add(x_prev_histword,		NULL, CTRL('['), '_', 0);
+	kb_add(x_prev_histword,		CTRL('['), '.', 0);
+	kb_add(x_prev_histword,		CTRL('['), '_', 0);
 	/* how to handle: quote: ^^ */
-	kb_add(x_draw_line,		NULL, CTRL('L'), 0);
-	kb_add(x_search_char_back,	NULL, CTRL('['), CTRL(']'), 0);
-	kb_add(x_search_char_forw,	NULL, CTRL(']'), 0);
-	kb_add(x_search_hist,		NULL, CTRL('R'), 0);
-	kb_add(x_set_mark,		NULL, CTRL('['), ' ', 0);
-#if defined(TIOCSTI)
-	kb_add(x_stuff,			NULL, CTRL('T'), 0);
-	/* stuff-reset */
-#else
-	kb_add(x_transpose,		NULL, CTRL('T'), 0);
-#endif
-	kb_add(x_prev_com,		NULL, CTRL('P'), 0);
-	kb_add(x_prev_com,		NULL, CTRL('X'), 'A', 0);
-	kb_add(x_fold_upper,		NULL, CTRL('['), 'U', 0);
-	kb_add(x_fold_upper,		NULL, CTRL('['), 'u', 0);
-	kb_add(x_literal,		NULL, CTRL('V'), 0);
-	kb_add(x_literal,		NULL, CTRL('^'), 0);
-	kb_add(x_yank,			NULL, CTRL('Y'), 0);
-	kb_add(x_meta_yank,		NULL, CTRL('['), 'y', 0);
+	kb_add(x_literal,		CTRL('^'), 0);
+	kb_add(x_clear_screen,		CTRL('L'), 0);
+	kb_add(x_search_char_back,	CTRL('['), CTRL(']'), 0);
+	kb_add(x_search_char_forw,	CTRL(']'), 0);
+	kb_add(x_search_hist,		CTRL('R'), 0);
+	kb_add(x_set_mark,		CTRL('['), ' ', 0);
+	kb_add(x_transpose,		CTRL('T'), 0);
+	kb_add(x_prev_com,		CTRL('P'), 0);
+	kb_add(x_prev_com,		CTRL('X'), 'A', 0);
+	kb_add(x_fold_upper,		CTRL('['), 'U', 0);
+	kb_add(x_fold_upper,		CTRL('['), 'u', 0);
+	kb_add(x_literal,		CTRL('V'), 0);
+	kb_add(x_yank,			CTRL('Y'), 0);
+	kb_add(x_meta_yank,		CTRL('['), 'y', 0);
 	/* man page ends here */
 
 	/* arrow keys */
-	kb_add(x_prev_com,		NULL, CTRL('['), '[', 'A', 0); /* up */
-	kb_add(x_next_com,		NULL, CTRL('['), '[', 'B', 0); /* down */
-	kb_add(x_mv_forw,		NULL, CTRL('['), '[', 'C', 0); /* right */
-	kb_add(x_mv_back,		NULL, CTRL('['), '[', 'D', 0); /* left */
-	kb_add(x_prev_com,		NULL, CTRL('['), 'O', 'A', 0); /* up */
-	kb_add(x_next_com,		NULL, CTRL('['), 'O', 'B', 0); /* down */
-	kb_add(x_mv_forw,		NULL, CTRL('['), 'O', 'C', 0); /* right */
-	kb_add(x_mv_back,		NULL, CTRL('['), 'O', 'D', 0); /* left */
+	kb_add(x_prev_com,		CTRL('['), '[', 'A', 0); /* up */
+	kb_add(x_next_com,		CTRL('['), '[', 'B', 0); /* down */
+	kb_add(x_mv_forw,		CTRL('['), '[', 'C', 0); /* right */
+	kb_add(x_mv_back,		CTRL('['), '[', 'D', 0); /* left */
+	kb_add(x_prev_com,		CTRL('['), 'O', 'A', 0); /* up */
+	kb_add(x_next_com,		CTRL('['), 'O', 'B', 0); /* down */
+	kb_add(x_mv_forw,		CTRL('['), 'O', 'C', 0); /* right */
+	kb_add(x_mv_back,		CTRL('['), 'O', 'D', 0); /* left */
 
 	/* more navigation keys */
-	kb_add(x_mv_begin,		NULL, CTRL('['), '[', 'H', 0); /* home */
-	kb_add(x_mv_end,		NULL, CTRL('['), '[', 'F', 0); /* end */
-	kb_add(x_mv_begin,		NULL, CTRL('['), 'O', 'H', 0); /* home */
-	kb_add(x_mv_end,		NULL, CTRL('['), 'O', 'F', 0); /* end */
+	kb_add(x_mv_begin,		CTRL('['), '[', 'H', 0); /* home */
+	kb_add(x_mv_end,		CTRL('['), '[', 'F', 0); /* end */
+	kb_add(x_mv_begin,		CTRL('['), 'O', 'H', 0); /* home */
+	kb_add(x_mv_end,		CTRL('['), 'O', 'F', 0); /* end */
+	kb_add(x_mv_begin,		CTRL('['), '[', '1', '~', 0); /* home */
+	kb_add(x_mv_end,		CTRL('['), '[', '4', '~', 0); /* end */
+	kb_add(x_mv_begin,		CTRL('['), '[', '7', '~', 0); /* home */
+	kb_add(x_mv_end,		CTRL('['), '[', '8', '~', 0); /* end */
 
 	/* can't be bound */
-	kb_add(x_set_arg,		NULL, CTRL('['), '0', 0);
-	kb_add(x_set_arg,		NULL, CTRL('['), '1', 0);
-	kb_add(x_set_arg,		NULL, CTRL('['), '2', 0);
-	kb_add(x_set_arg,		NULL, CTRL('['), '3', 0);
-	kb_add(x_set_arg,		NULL, CTRL('['), '4', 0);
-	kb_add(x_set_arg,		NULL, CTRL('['), '5', 0);
-	kb_add(x_set_arg,		NULL, CTRL('['), '6', 0);
-	kb_add(x_set_arg,		NULL, CTRL('['), '7', 0);
-	kb_add(x_set_arg,		NULL, CTRL('['), '8', 0);
-	kb_add(x_set_arg,		NULL, CTRL('['), '9', 0);
+	kb_add(x_set_arg,		CTRL('['), '0', 0);
+	kb_add(x_set_arg,		CTRL('['), '1', 0);
+	kb_add(x_set_arg,		CTRL('['), '2', 0);
+	kb_add(x_set_arg,		CTRL('['), '3', 0);
+	kb_add(x_set_arg,		CTRL('['), '4', 0);
+	kb_add(x_set_arg,		CTRL('['), '5', 0);
+	kb_add(x_set_arg,		CTRL('['), '6', 0);
+	kb_add(x_set_arg,		CTRL('['), '7', 0);
+	kb_add(x_set_arg,		CTRL('['), '8', 0);
+	kb_add(x_set_arg,		CTRL('['), '9', 0);
 
 	/* ctrl arrow keys */
-	kb_add(x_mv_end,		NULL, CTRL('['), '[', '1', ';', '5', 'A', 0); /* ctrl up */
-	kb_add(x_mv_begin,		NULL, CTRL('['), '[', '1', ';', '5', 'B', 0); /* ctrl down */
-	kb_add(x_mv_fword,		NULL, CTRL('['), '[', '1', ';', '5', 'C', 0); /* ctrl right */
-	kb_add(x_mv_bword,		NULL, CTRL('['), '[', '1', ';', '5', 'D', 0); /* ctrl left */
+	kb_add(x_mv_end,		CTRL('['), '[', '1', ';', '5', 'A', 0); /* ctrl up */
+	kb_add(x_mv_begin,		CTRL('['), '[', '1', ';', '5', 'B', 0); /* ctrl down */
+	kb_add(x_mv_fword,		CTRL('['), '[', '1', ';', '5', 'C', 0); /* ctrl right */
+	kb_add(x_mv_bword,		CTRL('['), '[', '1', ';', '5', 'D', 0); /* ctrl left */
 }
 
 void
@@ -1598,17 +1590,17 @@
 {
 	x_bind_quiet = 1;
 	if (ec->erase >= 0) {
-		kb_add(x_del_back, NULL, ec->erase, 0);
-		kb_add(x_del_bword, NULL, CTRL('['), ec->erase, 0);
+		kb_add(x_del_back, ec->erase, 0);
+		kb_add(x_del_bword, CTRL('['), ec->erase, 0);
 	}
 	if (ec->kill >= 0)
-		kb_add(x_del_line, NULL, ec->kill, 0);
+		kb_add(x_del_line, ec->kill, 0);
 	if (ec->werase >= 0)
-		kb_add(x_del_bword, NULL, ec->werase, 0);
+		kb_add(x_del_bword, ec->werase, 0);
 	if (ec->intr >= 0)
-		kb_add(x_abort, NULL, ec->intr, 0);
+		kb_add(x_abort, ec->intr, 0);
 	if (ec->quit >= 0)
-		kb_add(x_noop, NULL, ec->quit, 0);
+		kb_add(x_noop, ec->quit, 0);
 	x_bind_quiet = 0;
 }
 
@@ -1658,35 +1650,6 @@
 }
 
 static int
-x_version(int c)
-{
-	char *o_xbuf = xbuf, *o_xend = xend;
-	char *o_xbp = xbp, *o_xep = xep, *o_xcp = xcp;
-	int lim = x_lastcp() - xbp;
-
-	xbuf = xbp = xcp = (char *) ksh_version + 4;
-	xend = xep = (char *) ksh_version + 4 + strlen(ksh_version + 4);
-	x_redraw(lim);
-	x_flush();
-
-	c = x_e_getc();
-	xbuf = o_xbuf;
-	xend = o_xend;
-	xbp = o_xbp;
-	xep = o_xep;
-	xcp = o_xcp;
-	x_redraw(strlen(ksh_version));
-
-	if (c < 0)
-		return KSTD;
-	/* This is what at&t ksh seems to do...  Very bizarre */
-	if (c != ' ')
-		x_e_ungetc(c);
-
-	return KSTD;
-}
-
-static int
 x_noop(int c)
 {
 	return KSTD;
@@ -1758,8 +1721,8 @@
 	x_goto(xbuf + start);
 	x_delete(end - start, false);
 	for (i = 0; i < nwords;) {
-		if (x_escape(words[i], strlen(words[i]), x_emacs_putbuf) < 0 ||
-		    (++i < nwords && x_ins(space) < 0)) {
+		if (x_escape(words[i], strlen(words[i]), x_do_ins) < 0 ||
+		    (++i < nwords && x_ins(" ") < 0)) {
 			x_e_putc(BEL);
 			return KSTD;
 		}
@@ -1801,13 +1764,13 @@
 	if (nwords == 1 || nlen > olen) {
 		x_goto(xbuf + start);
 		x_delete(olen, false);
-		x_escape(words[0], nlen, x_emacs_putbuf);
+		x_escape(words[0], nlen, x_do_ins);
 		x_adjust();
 		completed = 1;
 	}
 	/* add space if single non-dir match */
 	if (nwords == 1 && words[0][nlen - 1] != '/') {
-		x_ins(space);
+		x_ins(" ");
 		completed = 1;
 	}
 
@@ -1878,6 +1841,50 @@
 	return c;
 }
 
+static int
+x_e_getu8(char *buf, int off)
+{
+	int	c, cc, len;
+
+	c = x_e_getc();
+	if (c == -1)
+		return -1;
+	buf[off++] = c;
+
+	/*
+	 * In the following, comments refer to violations of
+	 * the inequality tests at the ends of the lines.
+	 * See the utf8(7) manual page for details.
+	 */
+
+	if ((c & 0xf8) == 0xf0 && c < 0xf5)  /* beyond Unicode */
+		len = 4;
+	else if ((c & 0xf0) == 0xe0)
+		len = 3;
+	else if ((c & 0xe0) == 0xc0 && c > 0xc1)  /* use single byte */
+		len = 2;
+	else
+		len = 1;
+
+	for (; len > 1; len--) {
+		cc = x_e_getc();
+		if (cc == -1)
+			break;
+		if (isu8cont(cc) == 0 ||
+		    (c == 0xe0 && len == 3 && cc < 0xa0) ||  /* use 2 bytes */
+		    (c == 0xed && len == 3 && cc > 0x9f) ||  /* surrogates  */
+		    (c == 0xf0 && len == 4 && cc < 0x90) ||  /* use 3 bytes */
+		    (c == 0xf4 && len == 4 && cc > 0x8f)) {  /* beyond Uni. */
+			x_e_ungetc(cc);
+			break;
+		}
+		buf[off++] = cc;
+	}
+	buf[off] = '\0';
+
+	return off;
+}
+
 static void
 x_e_putc(int c)
 {
@@ -1895,7 +1902,8 @@
 			x_col--;
 			break;
 		default:
-			x_col++;
+			if (!isu8cont(c))
+				x_col++;
 			break;
 		}
 	}
@@ -1915,7 +1923,7 @@
 	shellf("\txbp == 0x%lx,\txbuf == 0x%lx\n", (long) xbp, (long) xbuf);
 	shellf("\txlp == 0x%lx\n", (long) xlp);
 	shellf("\txlp == 0x%lx\n", (long) x_lastcp());
-	shellf(newline);
+	shellf("\n");
 	x_redraw(-1);
 	return 0;
 }
@@ -2021,8 +2029,6 @@
 			rcp++;
 		x_ins(rcp);
 	} else {
-		int c;
-
 		rcp = cp;
 		/*
 		 * ignore white-space at start of line
@@ -2126,13 +2132,13 @@
 }
 
 /* NAME:
- *      x_lastcp - last visible char
+ *      x_lastcp - last visible byte
  *
  * SYNOPSIS:
  *      x_lastcp()
  *
  * DESCRIPTION:
- *      This function returns a pointer to that  char in the
+ *      This function returns a pointer to that byte in the
  *      edit buffer that will be the last displayed on the
  *      screen.  The sequence:
  *
@@ -2160,4 +2166,4 @@
 	return (xlp);
 }
 
-#endif /* EDIT */
+#endif /* EMACS */
--- bin/ksh/eval.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/eval.c	2025-09-14 09:30:00 +0200
@@ -854,6 +854,7 @@
 	if (t == NULL)
 		return XBASE;
 
+__DEBUG_SUBST("comsub(enter): xp(0x%x) type(%s) cp(%s)\n", xp, __T_TYPE[t->type], cp)
 	if (t != NULL && t->type == TCOM && /* $(<file) */
 	    *t->args == NULL && *t->vars == NULL && t->ioact != NULL) {
 		struct ioword *io = *t->ioact;
@@ -884,6 +885,7 @@
 	}
 
 	xp->u.shf = shf;
+__DEBUG_SUBST("comsub(leave): xp(0x%x) type(%s)\n", xp, __T_TYPE[t->type])
 	return XCOM;
 }
 
--- bin/ksh/exec.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/exec.c	2025-09-14 09:33:06 +0200
@@ -57,7 +57,9 @@
 	}
 	 */
 	if ((flags&XFORK) && !(flags&XEXEC) && t->type != TPIPE)
+{__DEBUG("execute(exchild)\n")
 		return exchild(t, flags & ~XTIME, xerrok, -1); /* run in sub-process */
+}
 
 	newenv(E_EXEC);
 	if (trap)
@@ -113,6 +115,7 @@
 			}
 		}
 
+__DEBUG("execute(enter): type(%s) flags(%s) xerrok(%d)\n", __T_TYPE[t->type], __X_FLAGS(flags), *xerrok)
 	switch (t->type) {
 	case TCOM:
 		rv = comexec(t, tp, ap, flags, xerrok);
@@ -356,10 +359,10 @@
 		break;
 
 	case TEXEC:		/* an eval'd TCOM */
+__DEBUG_SUBST("execute(execve): str(%s)\n", t->str)
 		s = t->args[0];
 		ap = makenv();
 		restoresigs();
-		cleanup_proc_env();
 		execve(t->str, t->args, ap);
 		if (errno == ENOEXEC)
 			scriptexec(t, ap);
@@ -371,13 +374,18 @@
 
 	quitenv(NULL);		/* restores IO */
 	if ((flags&XEXEC))
-		unwind(LEXIT);	/* exit child */
+{
+__DEBUG_EXIT("execute(exit)\n")
+exit(rv);
+}
+
 	if (rv != 0 && !(flags & XERROK) &&
 	    (xerrok == NULL || !*xerrok)) {
 		trapsig(SIGERR_);
 		if (Flag(FERREXIT))
 			unwind(LERROR);
 	}
+__DEBUG("execute(leave): type(%s)\n", __T_TYPE[t->type])
 	return rv;
 }
 
@@ -399,6 +407,7 @@
 	int fcflags = FC_BI|FC_FUNC|FC_PATH;
 	int bourne_function_call = 0;
 
+__DEBUG_SUBST("comexec(enter): flags(%s)\n", __X_FLAGS(flags))
 	/* snag the last argument for $_ XXX not the same as at&t ksh,
 	 * which only seems to set $_ after a newline (but not in
 	 * functions/dot scripts, but in interactive and script) -
@@ -677,10 +686,13 @@
 		break;
 	}
   Leave:
-	if (flags & XEXEC) {
+	if (rv != 0 && (flags & XEXEC)){
+__DEBUG_EXIT("comexec(exit): rv(%d)\n", rv)
 		exstat = rv;
+exit(rv);
 		unwind(LLEAVE);
 	}
+__DEBUG_SUBST("comexec(leave): rv(%d)\n", rv)
 	return rv;
 }
 
@@ -1008,6 +1020,7 @@
 {
 	int rv;
 
+__DEBUG_SUBST("call_builtin(%s)\n", *wp)
 	builtin_argv0 = wp[0];
 	builtin_flag = tp->flag;
 	shf_reopen(1, SHF_WR, shl_stdout);
--- bin/ksh/io.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/io.c	2025-09-14 04:22:38 +0200
@@ -93,6 +93,7 @@
 	va_end(va);
 	shf_putchar('\n', shl_out);
 	shf_flush(shl_out);
+abort();
 	if (jump)
 		unwind(LERROR);
 }
@@ -203,7 +204,7 @@
 	    SHF_UNBUF : 0;
 }
 
-struct shf	shf_iob[3];
+__thread struct shf	shf_iob[3];
 
 void
 initio(void)
--- bin/ksh/jobs.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/jobs.c	2025-09-14 09:37:26 +0200
@@ -105,24 +105,24 @@
 
 struct timeval	j_systime, j_usrtime;	/* user and system time of last j_waitjed job */
 
-static Job		*job_list;	/* job list */
-static Job		*last_job;
-static Job		*async_job;
-static pid_t		async_pid;
-
-static int		nzombie;	/* # of zombies owned by this process */
-INT32			njobs;		/* # of jobs started */
-static int		child_max;	/* CHILD_MAX */
+static __thread Job		*job_list;	/* job list */
+static __thread Job		*last_job;
+static __thread Job		*async_job;
+static __thread pid_t		async_pid;
+
+static __thread int		nzombie;	/* # of zombies owned by this process */
+__thread INT32			njobs;		/* # of jobs started */
+static __thread int		child_max;	/* CHILD_MAX */
 
 
 /* held_sigchld is set if sigchld occurs before a job is completely started */
-static volatile sig_atomic_t held_sigchld;
+static __thread volatile sig_atomic_t held_sigchld;
 
 #ifdef JOBS
-static struct shf	*shl_j;
-static int		ttypgrp_ok;	/* set if can use tty pgrps */
+static __thread struct shf	*shl_j;
+static __thread int		ttypgrp_ok;	/* set if can use tty pgrps */
 static pid_t		restore_ttypgrp = -1;
-static pid_t		our_pgrp;
+static __thread pid_t		our_pgrp;
 static int const	tt_sigs[] = { SIGTSTP, SIGTTIN, SIGTTOU };
 #endif /* JOBS */
 
@@ -247,6 +247,7 @@
 	Job	*j;
 	int	killed = 0;
 
+__DEBUG_EXIT("j_exit(enter)\n")
 	for (j = job_list; j != (Job *) 0; j = j->next) {
 		if (j->ppid == procpid &&
 		    (j->state == PSTOPPED ||
@@ -330,6 +331,7 @@
 					ttypgrp_ok = 0;
 					break;
 				}
+__DEBUG("j_change(): ttypgrp(%d) our_pgrp(%d)\n", ttypgrp, our_pgrp)
 				if (ttypgrp == our_pgrp)
 					break;
 				kill(0, SIGTTIN);
@@ -401,8 +403,11 @@
 		/* Clear XFORK|XPCLOSE|XCCLOSE|XCOPROC|XPIPEO|XPIPEI|XXCOM|XBGND
 		 * (also done in another execute() below)
 		 */
+{__DEBUG("exchild(execute)\n")
 		return execute(t, flags & (XEXEC | XERROK), xerrok);
+}
 
+__DEBUG_JOBS("exchild(enter): flags(%s)\n", __X_FLAGS(flags))
 	/* no SIGCHLD's while messing with job and process lists */
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
 
@@ -495,7 +500,6 @@
 		if (flags & XCOPROC)
 			coproc_cleanup(false);
 		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
-		cleanup_parents_env();
 #ifdef JOBS
 		/* If FMONITOR or FTALKING is set, these signals are ignored,
 		 * if neither FMONITOR nor FTALKING are set, the signals have
@@ -522,7 +526,8 @@
 				}
 			}
 		}
-		remove_job(j, "child");	/* in case of `jobs` command */
+last_job = (Job *) 0;
+async_job = (Job *) 0;
 		nzombie = 0;
 #ifdef JOBS
 		ttypgrp_ok = 0;
@@ -530,7 +535,6 @@
 #endif /* JOBS */
 		Flag(FTALKING) = 0;
 		tty_close();
-		cleartraps();
 		execute(t, (flags & XERROK) | XEXEC, NULL); /* no return */
 		internal_errorf(0, "exchild: execute() returned");
 		unwind(LLEAVE);
@@ -540,6 +544,7 @@
 	/* shell (parent) stuff */
 	/* Ensure next child gets a (slightly) different $RANDOM sequence */
 	change_random();
+__DEBUG_JOBS("exchild(j_waitj): flags(%s)\n", __X_FLAGS(flags))
 	if (!(flags & XPIPEO)) {	/* last process in a job */
 #ifdef JOBS
 		/* YYY: Is this needed? (see also YYY above)
@@ -565,6 +570,7 @@
 		} else
 			rv = j_waitj(j, JW_NONE, "jw:last proc");
 	}
+//else sleep(1);	// eval.c:expand() hangs in pipe (switch(XCOM)/read())
 
 	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
 
@@ -598,6 +604,7 @@
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
 
 	j = last_job;
+__DEBUG_JOBS("waitlast(0x%x)\n", j)
 	if (!j || !(j->flags & JF_STARTED)) {
 		if (!j)
 			warningf(true, "waitlast: no last job");
@@ -1027,6 +1034,7 @@
 
 	while ((volatile int) j->state == PRUNNING ||
 	    ((flags & JW_STOPPEDWAIT) && (volatile int) j->state == PSTOPPED)) {
+__DEBUG_JOBS("j_waitj(enter): where(%s) flags(%s) state(%s)\n", where, __JW_FLAGS(flags), __STATE[j->state])
 		sigsuspend(&sm_default);
 		if (fatal_trap) {
 			int oldf = j->flags & (JF_WAITING|JF_W_ASYNCNOTIFY);
@@ -1129,6 +1137,7 @@
 	    (!Flag(FMONITOR) || !(flags & JW_ASYNCNOTIFY)))
 		remove_job(j, where);
 
+__DEBUG_JOBS("j_waitj(leave): where(%s)\n", where)
 	return rv;
 }
 
@@ -1147,6 +1156,7 @@
 	int		status;
 	struct rusage	ru0, ru1;
 
+__DEBUG_JOBS("j_sigchld(enter)\n")
 	/* Don't wait for any processes if a job is partially started.
 	 * This is so we don't do away with the process group leader
 	 * before all the processes in a pipe line are started (so the
@@ -1200,6 +1210,7 @@
 
 		check_job(j);	/* check to see if entire job is done */
 	} while (1);
+__DEBUG_JOBS("j_sigchld(leave)\n")
 
 finished:
 	errno = errno_;
@@ -1228,6 +1239,7 @@
 
 	jstate = PRUNNING;
 	for (p=j->proc_list; p != (Proc *) 0; p = p->next) {
+__DEBUG_JOBS("check_job(0x%x): proc(%d) state(%s)\n", j, p->pid, __STATE[p->state])
 		if (p->state == PRUNNING)
 			return;	/* some processes still running */
 		if (p->state > jstate)
@@ -1510,8 +1522,8 @@
 	return (Job *) 0;
 }
 
-static Job	*free_jobs;
-static Proc	*free_procs;
+static __thread Job	*free_jobs;
+static __thread Proc	*free_procs;
 
 /* allocate a new job and fill in the job number.
  *
@@ -1570,6 +1582,7 @@
 	Proc	*p, *tmp;
 	Job	**prev, *curr;
 
+__DEBUG_JOBS("remove_job(0x%x): where(%s)\n", j, where);
 	prev = &job_list;
 	curr = *prev;
 	for (; curr != (Job *) 0 && curr != j; prev = &curr->next, curr = *prev)
--- bin/ksh/ksh.1	2014-05-19 17:05:13 +0200
+++ bin/ksh/ksh.1	2025-09-14 06:25:34 +0200
@@ -5609,7 +5609,7 @@
     System Interface (POSIX) \- Part 2: Shell and Utilities
 .Re
 .Sh VERSION
-This page documents version @(#)PD KSH v5.2.14 99/07/13.2 of the public
+This page documents version @(#)PD KSH v5.2.15 20/07/31.1 of the public
 domain Korn shell.
 .Sh AUTHORS
 .An -nosplit
--- bin/ksh/main.c	2025-09-14 09:39:49 +0200
+++ bin/ksh/main.c	2025-09-14 09:40:26 +0200
@@ -512,6 +512,7 @@
 	if (interactive)
 		really_exit = 0;
 	i = sigsetjmp(e->jbuf, 0);
+__DEBUG("shell(%s)\n", __L_TYPE[i])
 	if (i) {
 		switch (i) {
 		case LINTR: /* we get here if SIGINT not caught or ignored */
@@ -608,6 +609,7 @@
 void
 unwind(int i)
 {
+__DEBUG("unwind(enter): type(%s)\n", __L_TYPE[i])
 	/* ordering for EXIT vs ERR is a bit odd (this is what at&t ksh does) */
 	if (i == LEXIT || (Flag(FERREXIT) && (i == LERROR || i == LINTR) &&
 	    sigtraps[SIGEXIT_].trap)) {
@@ -622,6 +624,7 @@
 		i = LLEAVE;
 	}
 	while (1) {
+__DEBUG_EXIT("unwind(%s): type(%s)\n", __L_TYPE[i], __E_TYPE[e->type])
 		switch (e->type) {
 		case E_PARSE:
 		case E_FUNC:
@@ -675,6 +678,7 @@
 			shf_reopen(2, SHF_WR, shl_out);
 	}
 
+__DEBUG_EXIT("quitenv(%s): oenv(0x%x) pid(%d)\n", __E_TYPE[ep->type], ep->oenv, getpid())
 	/* Bottom of the stack.
 	 * Either main shell is exiting or cleanup_parents_env() was called.
 	 */
@@ -743,6 +747,7 @@
 {
 	struct env *ep;
 
+__DEBUG_JOBS("cleanup_proc_env()\n")
 	for (ep = e; ep; ep = ep->oenv)
 		remove_temps(ep->temps);
 }
--- bin/ksh/path.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/path.c	2025-09-14 09:42:01 +0200
@@ -42,6 +42,7 @@
 	int	plen = 0;
 	char	*xp = Xstring(*xsp, xp);
 
+__DEBUG("make_path(%s): file(%s)\n", cwd, file)
 	if (!file)
 		file = null;
 
@@ -182,11 +183,13 @@
 
 	len = strlen(p) + 1;
 
-	if (len > current_wd_size)
-		current_wd = aresize(current_wd, current_wd_size = len, APERM);
+/* aresize() calling realloc(), destroys parent's path */
+current_wd = alloc(current_wd_size = len, APERM);
+
 	memcpy(current_wd, p, len);
 	if (p != path && p != null)
 		afree(p, ATEMP);
+__DEBUG("set_current_wd(0x%x): path(%s)\n", current_wd, path)
 }
 
 char *
--- bin/ksh/sh.h	2014-05-19 17:05:13 +0200
+++ bin/ksh/sh.h	2025-09-14 04:26:52 +0200
@@ -69,13 +69,13 @@
 #define	LINE	2048		/* input line size */
 #define	PATH	1024		/* pathname size (todo: PATH_MAX/pathconf()) */
 
-EXTERN	const char *kshname;	/* $0 */
-EXTERN	pid_t	kshpid;		/* $$, shell pid */
-EXTERN	pid_t	procpid;	/* pid of executing process */
-EXTERN	uid_t	ksheuid;	/* effective uid of shell */
-EXTERN	int	exstat;		/* exit status */
-EXTERN	int	subst_exstat;	/* exit status of last $(..)/`..` */
-EXTERN	const char *safe_prompt; /* safe prompt if PS1 substitution fails */
+EXTERN __thread	const char *kshname;	/* $0 */
+EXTERN __thread	pid_t	kshpid;		/* $$, shell pid */
+EXTERN __thread	pid_t	procpid;	/* pid of executing process */
+EXTERN __thread	uid_t	ksheuid;	/* effective uid of shell */
+EXTERN __thread	int	exstat;		/* exit status */
+EXTERN __thread	int	subst_exstat;	/* exit status of last $(..)/`..` */
+EXTERN __thread	const char *safe_prompt; /* safe prompt if PS1 substitution fails */
 EXTERN	char	username[];	/* username for \u prompt expansion */
 
 /*
@@ -85,7 +85,7 @@
 	struct link *freelist;	/* free list */
 } Area;
 
-EXTERN	Area	aperm;		/* permanent object space */
+EXTERN __thread Area	aperm;		/* permanent object space */
 #define	APERM	&aperm
 #define	ATEMP	&e->area
 
@@ -102,7 +102,7 @@
 /*
  * parsing & execution environment
  */
-EXTERN	struct env {
+EXTERN __thread	struct env {
 	short	type;			/* environment type - see below */
 	short	flags;			/* EF_* */
 	Area	area;			/* temporary allocation area */
@@ -215,7 +215,7 @@
 
 #define Flag(f)	(shell_flags[(int) (f)])
 
-EXTERN	char shell_flags [FNFLAGS];
+EXTERN __thread	char shell_flags [FNFLAGS];
 
 EXTERN	char	null [] I__("");	/* null value for variable */
 EXTERN	char	space [] I__(" ");
@@ -242,7 +242,7 @@
 #define shl_spare	(&shf_iob[0])	/* for c_read()/c_print() */
 #define shl_stdout	(&shf_iob[1])
 #define shl_out		(&shf_iob[2])
-EXTERN int shl_stdout_ok;
+EXTERN __thread int shl_stdout_ok;
 
 /*
  * trap handlers
@@ -283,11 +283,11 @@
 #define SIGEXIT_	0	/* for trap EXIT */
 #define SIGERR_		NSIG	/* for trap ERR */
 
-EXTERN	volatile sig_atomic_t trap;	/* traps pending? */
-EXTERN	volatile sig_atomic_t intrsig;	/* pending trap interrupts command */
-EXTERN	volatile sig_atomic_t fatal_trap;/* received a fatal signal */
+EXTERN __thread	volatile sig_atomic_t trap;	/* traps pending? */
+EXTERN __thread	volatile sig_atomic_t intrsig;	/* pending trap interrupts command */
+EXTERN __thread	volatile sig_atomic_t fatal_trap;/* received a fatal signal */
 extern	volatile sig_atomic_t got_sigwinch;
-extern	Trap	sigtraps[NSIG+1];
+extern __thread	Trap	sigtraps[NSIG+1];
 
 /*
  * TMOUT support
@@ -298,11 +298,11 @@
 	TMOUT_READING,		/* waiting for input */
 	TMOUT_LEAVING		/* have timed out */
 };
-EXTERN unsigned int ksh_tmout;
+EXTERN __thread unsigned int ksh_tmout;
 EXTERN enum tmout_enum ksh_tmout_state I__(TMOUT_EXECUTING);
 
 /* For "You have stopped jobs" message */
-EXTERN int really_exit;
+EXTERN __thread int really_exit;
 
 /*
  * fast character classes
@@ -348,8 +348,8 @@
 	char		buf[2];	/* for bad option OPTARG value */
 } Getopt;
 
-EXTERN Getopt builtin_opt;	/* for shell builtin commands */
-EXTERN Getopt user_opt;		/* parsing state for getopts builtin command */
+EXTERN __thread Getopt builtin_opt;	/* for shell builtin commands */
+EXTERN __thread Getopt user_opt;		/* parsing state for getopts builtin command */
 
 /* This for co-processes */
 
@@ -362,20 +362,20 @@
 	int	njobs;		/* number of live jobs using output pipe */
 	void	*job;		/* 0 or job of co-process using input pipe */
 };
-EXTERN struct coproc coproc;
+EXTERN __thread struct coproc coproc;
 
 /* Used in jobs.c and by coprocess stuff in exec.c */
-EXTERN sigset_t		sm_default, sm_sigchld;
+EXTERN __thread sigset_t		sm_default, sm_sigchld;
 
 extern const char ksh_version[];
 
 /* name of called builtin function (used by error functions) */
-EXTERN char	*builtin_argv0;
-EXTERN Tflag	builtin_flag;	/* flags of called builtin (SPEC_BI, etc.) */
+EXTERN __thread char	*builtin_argv0;
+EXTERN __thread Tflag	builtin_flag;	/* flags of called builtin (SPEC_BI, etc.) */
 
 /* current working directory, and size of memory allocated for same */
-EXTERN char	*current_wd;
-EXTERN int	current_wd_size;
+EXTERN __thread char	*current_wd;
+EXTERN __thread int	current_wd_size;
 
 #ifdef EDIT
 /* Minimum required space to work with on a line - if the prompt leaves less
@@ -411,6 +411,7 @@
 #include "expand.h"
 #include "lex.h"
 #include "proto.h"
+#include "debug.h"
 
 /* be sure not to interfere with anyone else's idea about EXTERN */
 #ifdef EXTERN_DEFINED
--- bin/ksh/shf.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/shf.c	2025-09-14 04:22:38 +0200
@@ -214,6 +214,7 @@
 {
 	int ret = 0;
 
+__DEBUG_JOBS("shf_close(0x%x)\n", shf)
 	if (shf->fd >= 0) {
 		ret = shf_flush(shf);
 		if (close(shf->fd) < 0)
--- bin/ksh/shf.h	2014-05-19 17:05:13 +0200
+++ bin/ksh/shf.h	2025-09-14 04:26:52 +0200
@@ -57,7 +57,7 @@
 	Area *areap;		/* area shf/buf were allocated in */
 };
 
-extern struct shf shf_iob[];
+extern __thread struct shf shf_iob[];
 
 struct shf *shf_open(const char *, int, int, int);
 struct shf *shf_fdopen(int, int, struct shf *);
--- bin/ksh/syn.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/syn.c	2025-09-14 09:43:03 +0200
@@ -40,12 +40,12 @@
 		    int);
 static void	dbtestp_error(Test_env *, int, const char *);
 
-static	struct	op	*outtree; /* yyparse output */
+static	__thread struct	op	*outtree; /* yyparse output */
 
-static struct nesting_state nesting;	/* \n changed to ; */
+static __thread struct nesting_state nesting;	/* \n changed to ; */
 
-static	int	reject;		/* token(cf) gets symbol again */
-static	int	symbol;		/* yylex value */
+static	__thread int	reject;		/* token(cf) gets symbol again */
+static	__thread int	symbol;		/* yylex value */
 
 #define	REJECT	(reject = 1)
 #define	ACCEPT	(reject = 0)
--- bin/ksh/trap.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/trap.c	2025-09-14 09:43:55 +0200
@@ -6,9 +6,9 @@
 
 #include "sh.h"
 
-Trap sigtraps[NSIG + 1];
+__thread Trap sigtraps[NSIG + 1];
 
-static struct sigaction Sigact_ign, Sigact_trap;
+static __thread struct sigaction Sigact_ign, Sigact_trap;
 
 void
 inittraps(void)
@@ -45,6 +45,7 @@
 	setsig(&sigtraps[SIGQUIT], trapsig, SS_RESTORE_ORIG);
 	setsig(&sigtraps[SIGTERM], trapsig, SS_RESTORE_ORIG);
 	setsig(&sigtraps[SIGHUP], trapsig, SS_RESTORE_ORIG);
+__DEBUG_JOBS("inittraps: trapsig(0x%x)\n", trapsig)
 }
 
 static void alarm_catcher(int sig);
@@ -122,6 +123,8 @@
 		fatal_trap = 1;
 		intrsig = 1;
 	}
+__DEBUG_JOBS("trapsig(%s): cursig(0x%x) shtrap(0x%x) trap(%s)\n", 
+		p->name, p->cursig, p->shtrap, p->trap)
 	if (p->shtrap)
 		(*p->shtrap)(i);
 	errno = errno_;
--- bin/ksh/tty.h	2014-05-19 17:05:13 +0200
+++ bin/ksh/tty.h	2025-09-14 04:26:52 +0200
@@ -22,7 +22,7 @@
 
 #include <termios.h>
 
-EXTERN int		tty_fd I__(-1);	/* dup'd tty file descriptor */
+EXTERN __thread int		tty_fd I__(-1);	/* dup'd tty file descriptor */
 EXTERN int		tty_devtty;	/* true if tty_fd is from /dev/tty */
 EXTERN struct termios	tty_state;	/* saved tty state */
 
--- bin/ksh/version.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/version.c	2025-09-14 04:22:38 +0200
@@ -7,4 +7,4 @@
 #include "sh.h"
 
 const char ksh_version [] =
-	"@(#)PD KSH v5.2.14 99/07/13.2";
+	"@(#)PD KSH v5.2.15 20/07/31.1";
--- bin/ksh/vi.c	2014-05-19 17:05:13 +0200
+++ bin/ksh/vi.c	2025-09-14 04:22:38 +0200
@@ -1,4 +1,4 @@
-/*	$OpenBSD: src/bin/ksh/vi.c,v 1.28 2013/12/18 16:45:46 deraadt Exp $	*/
+/*	$OpenBSD: vi.c,v 1.60 2021/03/12 02:10:25 millert Exp $	*/
 
 /*
  *	vi command editing
@@ -9,21 +9,28 @@
 #include "config.h"
 #ifdef VI
 
-#include "sh.h"
-#include <ctype.h>
 #include <sys/stat.h>		/* completion */
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#ifndef SMALL
+# include <term.h>
+# include <curses.h>
+#endif
+
+#include "sh.h"
 #include "edit.h"
 
-#define CMDLEN		2048
-#define Ctrl(c)		(c&0x1f)
-#define	is_wordch(c)	(letnum(c))
+#undef CTRL
+#define	CTRL(x)		((x) & 0x1F)	/* ASCII */
 
 struct edstate {
-	int	winleft;
-	char	*cbuf;
-	int	cbufsize;
-	int	linelen;
-	int	cursor;
+	char	*cbuf;		/* main buffer to build the command line */
+	int	cbufsize;	/* number of bytes allocated for cbuf */
+	int	linelen;	/* current number of bytes in cbuf */
+	int	winleft;	/* first byte# in cbuf to be displayed */
+	int	cursor;		/* byte# in cbuf having the cursor */
 };
 
 
@@ -50,8 +57,9 @@
 static int	Endword(int);
 static int	grabhist(int, int);
 static int	grabsearch(int, int, int, char *);
-static void	redraw_line(int);
-static void	refresh(int);
+static void	do_clear_screen(void);
+static void	redraw_line(int, int);
+static void	refresh_line(int);
 static int	outofwin(void);
 static void	rewindow(void);
 static int	newcol(int, int);
@@ -59,13 +67,14 @@
 static void	ed_mov_opt(int, char *);
 static int	expand_word(int);
 static int	complete_word(int, int);
-static int	print_expansions(struct edstate *, int);
+static int	print_expansions(struct edstate *);
 static int	char_len(int);
 static void	x_vi_zotc(int);
 static void	vi_pprompt(int);
 static void	vi_error(void);
 static void	vi_macro_reset(void);
 static int	x_vi_putbuf(const char *, size_t);
+static int	isu8cont(unsigned char);
 
 #define C_	0x1		/* a valid command that isn't a M_, E_, U_ */
 #define M_	0x2		/* movement command (h, l, etc.) */
@@ -137,26 +146,25 @@
 #define VREDO		7		/* . */
 #define VLIT		8		/* ^V */
 #define VSEARCH		9		/* /, ? */
-#define VVERSION	10		/* <ESC> ^V */
 
-static char		undocbuf[CMDLEN];
+static char		undocbuf[LINE];
 
 static struct edstate	*save_edstate(struct edstate *old);
 static void		restore_edstate(struct edstate *old, struct edstate *new);
 static void		free_edstate(struct edstate *old);
 
 static struct edstate	ebuf;
-static struct edstate	undobuf = { 0, undocbuf, CMDLEN, 0, 0 };
+static struct edstate	undobuf = { undocbuf, LINE, 0, 0, 0 };
 
 static struct edstate	*es;			/* current editor state */
 static struct edstate	*undo;
 
-static char	ibuf[CMDLEN];		/* input buffer */
+static char	ibuf[LINE];		/* input buffer */
 static int	first_insert;		/* set when starting in insert mode */
 static int	saved_inslen;		/* saved inslen for first insert */
 static int	inslen;			/* length of input buffer */
-static int	srchlen;		/* length of current search pattern */
-static char	ybuf[CMDLEN];		/* yank buffer */
+static int	srchlen;		/* number of bytes in search pattern */
+static char	ybuf[LINE];		/* yank buffer */
 static int	yanklen;		/* length of yank buffer */
 static int	fsavecmd = ' ';		/* last find command */
 static int	fsavech;		/* character to find */
@@ -164,7 +172,7 @@
 static int	lastac;			/* argcnt for lastcmd */
 static int	lastsearch = ' ';	/* last search command */
 static char	srchpat[SRCHLEN];	/* last search pattern */
-static int	insert;			/* non-zero in insert mode */
+static int	insert;			/* mode: INSERT, REPLACE, or 0 */
 static int	hnum;			/* position in history */
 static int	ohnum;			/* history line copied (after mod) */
 static int	hlast;			/* 1 past last position in history */
@@ -192,7 +200,7 @@
 {
 	int	c;
 
-	vi_reset(buf, len > CMDLEN ? CMDLEN : len);
+	vi_reset(buf, len > LINE ? LINE : len);
 	vi_pprompt(1);
 	x_flush();
 	while (1) {
@@ -220,7 +228,7 @@
 				trapsig(c == edchars.intr ? SIGINT : SIGQUIT);
 				x_mode(false);
 				unwind(LSHELL);
-			} else if (c == edchars.eof && state != VVERSION) {
+			} else if (c == edchars.eof) {
 				if (es->linelen == 0) {
 					x_vi_zotc(edchars.eof);
 					c = -1;
@@ -236,7 +244,7 @@
 
 	x_putc('\r'); x_putc('\n'); x_flush();
 
-	if (c == -1 || len <= es->linelen)
+	if (c == -1 || len <= (size_t)es->linelen)
 		return -1;
 
 	if (es->cbuf != buf)
@@ -257,7 +265,7 @@
 
 	case VNORMAL:
 		if (insert != 0) {
-			if (ch == Ctrl('v')) {
+			if (ch == CTRL('v')) {
 				state = VLIT;
 				ch = '^';
 			}
@@ -269,9 +277,9 @@
 			case 0:
 				if (state == VLIT) {
 					es->cursor--;
-					refresh(0);
+					refresh_line(0);
 				} else
-					refresh(insert != 0);
+					refresh_line(insert != 0);
 				break;
 			case 1:
 				return 1;
@@ -296,15 +304,7 @@
 							return -1;
 					} else if (putbuf("?", 1, 0) != 0)
 						return -1;
-					refresh(0);
-				}
-				if (state == VVERSION) {
-					save_cbuf();
-					es->cursor = 0;
-					es->linelen = 0;
-					putbuf(ksh_version + 4,
-					    strlen(ksh_version + 4), 0);
-					refresh(0);
+					refresh_line(0);
 				}
 			}
 		}
@@ -316,14 +316,8 @@
 			vi_error();
 		} else
 			es->cbuf[es->cursor++] = ch;
-		refresh(1);
-		state = VNORMAL;
-		break;
-
-	case VVERSION:
-		restore_cbuf();
+		refresh_line(1);
 		state = VNORMAL;
-		refresh(0);
 		break;
 
 	case VARG1:
@@ -371,7 +365,7 @@
 		break;
 
 	case VXCH:
-		if (ch == Ctrl('['))
+		if (ch == CTRL('['))
 			state = VNORMAL;
 		else {
 			curcmd[cmdlen++] = ch;
@@ -380,14 +374,14 @@
 		break;
 
 	case VSEARCH:
-		if (ch == '\r' || ch == '\n' /*|| ch == Ctrl('[')*/ ) {
+		if (ch == '\r' || ch == '\n' /*|| ch == CTRL('[')*/ ) {
 			restore_cbuf();
 			/* Repeat last search? */
 			if (srchlen == 0) {
 				if (!srchpat[0]) {
 					vi_error();
 					state = VNORMAL;
-					refresh(0);
+					refresh_line(0);
 					return 0;
 				}
 			} else {
@@ -395,22 +389,26 @@
 				(void) strlcpy(srchpat, locpat, sizeof srchpat);
 			}
 			state = VCMD;
-		} else if (ch == edchars.erase || ch == Ctrl('h')) {
+		} else if (ch == edchars.erase || ch == CTRL('h')) {
 			if (srchlen != 0) {
-				srchlen--;
-				es->linelen -= char_len((unsigned char)locpat[srchlen]);
+				do {
+					srchlen--;
+					es->linelen -= char_len(
+					    (unsigned char)locpat[srchlen]);
+				} while (srchlen > 0 &&
+				    isu8cont(locpat[srchlen]));
 				es->cursor = es->linelen;
-				refresh(0);
+				refresh_line(0);
 				return 0;
 			}
 			restore_cbuf();
 			state = VNORMAL;
-			refresh(0);
+			refresh_line(0);
 		} else if (ch == edchars.kill) {
 			srchlen = 0;
 			es->linelen = 1;
 			es->cursor = 1;
-			refresh(0);
+			refresh_line(0);
 			return 0;
 		} else if (ch == edchars.werase) {
 			struct edstate new_es, *save_es;
@@ -429,7 +427,7 @@
 				es->linelen -= char_len((unsigned char)locpat[i]);
 			srchlen = n;
 			es->cursor = es->linelen;
-			refresh(0);
+			refresh_line(0);
 			return 0;
 		} else {
 			if (srchlen == SRCHLEN - 1)
@@ -454,7 +452,7 @@
 					es->cbuf[es->linelen++] = ch;
 				}
 				es->cursor = es->linelen;
-				refresh(0);
+				refresh_line(0);
 			}
 			return 0;
 		}
@@ -467,15 +465,15 @@
 		switch (vi_cmd(argc1, curcmd)) {
 		case -1:
 			vi_error();
-			refresh(0);
+			refresh_line(0);
 			break;
 		case 0:
 			if (insert != 0)
 				inslen = 0;
-			refresh(insert != 0);
+			refresh_line(insert != 0);
 			break;
 		case 1:
-			refresh(0);
+			refresh_line(0);
 			return 1;
 		case 2:
 			/* back from a 'v' command - don't redraw the screen */
@@ -490,7 +488,7 @@
 		switch (vi_cmd(lastac, lastcmd)) {
 		case -1:
 			vi_error();
-			refresh(0);
+			refresh_line(0);
 			break;
 		case 0:
 			if (insert != 0) {
@@ -503,10 +501,10 @@
 						vi_error();
 				}
 			}
-			refresh(0);
+			refresh_line(0);
 			break;
 		case 1:
-			refresh(0);
+			refresh_line(0);
 			return 1;
 		case 2:
 			/* back from a 'v' command - can't happen */
@@ -547,8 +545,6 @@
 		return VXCH;
 	else if (ch == '.')
 		return VREDO;
-	else if (ch == Ctrl('v'))
-		return VVERSION;
 	else if (is_cmd(ch))
 		return VCMD;
 	else
@@ -560,31 +556,34 @@
 {
 	int	tcursor;
 
-	if (ch == edchars.erase || ch == Ctrl('h')) {
+	if (ch == edchars.erase || ch == CTRL('h')) {
 		if (insert == REPLACE) {
 			if (es->cursor == undo->cursor) {
 				vi_error();
 				return 0;
 			}
-			if (inslen > 0)
-				inslen--;
-			es->cursor--;
-			if (es->cursor >= undo->linelen)
-				es->linelen--;
-			else
-				es->cbuf[es->cursor] = undo->cbuf[es->cursor];
 		} else {
 			if (es->cursor == 0) {
 				/* x_putc(BEL); no annoying bell here */
 				return 0;
 			}
-			if (inslen > 0)
-				inslen--;
-			es->cursor--;
-			es->linelen--;
-			memmove(&es->cbuf[es->cursor], &es->cbuf[es->cursor+1],
-			    es->linelen - es->cursor + 1);
 		}
+		tcursor = es->cursor - 1;
+		while(tcursor > 0 && isu8cont(es->cbuf[tcursor]))
+			tcursor--;
+		if (insert == INSERT)
+			memmove(es->cbuf + tcursor, es->cbuf + es->cursor,
+			    es->linelen - es->cursor);
+		if (insert == REPLACE && es->cursor < undo->linelen)
+			memcpy(es->cbuf + tcursor, undo->cbuf + tcursor,
+			    es->cursor - tcursor);
+		else
+			es->linelen -= es->cursor - tcursor;
+		if (inslen < es->cursor - tcursor)
+			inslen = 0;
+		else
+			inslen -= es->cursor - tcursor;
+		es->cursor = tcursor;
 		expanded = NONE;
 		return 0;
 	}
@@ -618,7 +617,7 @@
 	 * buffer (if user inserts & deletes char, ibuf gets trashed and
 	 * we don't want to use it)
 	 */
-	if (first_insert && ch != Ctrl('['))
+	if (first_insert && ch != CTRL('['))
 		saved_inslen = 0;
 	switch (ch) {
 	case '\0':
@@ -628,7 +627,7 @@
 	case '\n':
 		return 1;
 
-	case Ctrl('['):
+	case CTRL('['):
 		expanded = NONE;
 		if (first_insert) {
 			first_insert = 0;
@@ -646,19 +645,27 @@
 			return redo_insert(lastac - 1);
 
 	/* { Begin nonstandard vi commands */
-	case Ctrl('x'):
+	case CTRL('x'):
 		expand_word(0);
 		break;
 
-	case Ctrl('f'):
+	case CTRL('f'):
 		complete_word(0, 0);
 		break;
 
-	case Ctrl('e'):
-		print_expansions(es, 0);
+	case CTRL('e'):
+		print_expansions(es);
 		break;
 
-	case Ctrl('i'):
+	case CTRL('l'):
+		do_clear_screen();
+		break;
+
+	case CTRL('r'):
+		redraw_line(1, 0);
+		break;
+
+	case CTRL('i'):
 		if (Flag(FVITABCOMPLETE)) {
 			complete_word(0, 0);
 			break;
@@ -697,7 +704,8 @@
 	if (is_move(*cmd)) {
 		if ((cur = domove(argcnt, cmd, 0)) >= 0) {
 			if (cur == es->linelen && cur != 0)
-				cur--;
+				while (isu8cont(es->cbuf[--cur]))
+					continue;
 			es->cursor = cur;
 		} else
 			return -1;
@@ -713,9 +721,12 @@
 		}
 		switch (*cmd) {
 
-		case Ctrl('l'):
-		case Ctrl('r'):
-			redraw_line(1);
+		case CTRL('l'):
+			do_clear_screen();
+			break;
+
+		case CTRL('r'):
+			redraw_line(1, 0);
 			break;
 
 		case '@':
@@ -758,7 +769,8 @@
 		case 'a':
 			modified = 1; hnum = hlast;
 			if (es->linelen != 0)
-				es->cursor++;
+				while (isu8cont(es->cbuf[++es->cursor]))
+					continue;
 			insert = INSERT;
 			break;
 
@@ -886,7 +898,7 @@
 
 		case 'j':
 		case '+':
-		case Ctrl('n'):
+		case CTRL('n'):
 			if (grabhist(modified, hnum + argcnt) < 0)
 				return -1;
 			else {
@@ -897,7 +909,7 @@
 
 		case 'k':
 		case '-':
-		case Ctrl('p'):
+		case CTRL('p'):
 			if (grabhist(modified, hnum - argcnt) < 0)
 				return -1;
 			else {
@@ -913,13 +925,24 @@
 			if (cmd[1] == 0)
 				vi_error();
 			else {
-				int	n;
-
-				if (es->cursor + argcnt > es->linelen)
+				c1 = 0;
+				for (cur = es->cursor;
+				    cur < es->linelen; cur++) {
+					if (!isu8cont(es->cbuf[cur]))
+						c1++;
+					if (c1 > argcnt)
+						break;
+				}
+				if (argcnt > c1)
 					return -1;
-				for (n = 0; n < argcnt; ++n)
-					es->cbuf[es->cursor + n] = cmd[1];
-				es->cursor += n - 1;
+
+				del_range(es->cursor, cur);
+				while (argcnt-- > 0)
+					putbuf(&cmd[1], 1, 0);
+				while (es->cursor > 0)
+					if (!isu8cont(es->cbuf[--es->cursor]))
+						break;
+				es->cbuf[es->linelen] = '\0';
 			}
 			break;
 
@@ -932,9 +955,11 @@
 			if (es->linelen == 0)
 				return -1;
 			modified = 1; hnum = hlast;
-			if (es->cursor + argcnt > es->linelen)
-				argcnt = es->linelen - es->cursor;
-			del_range(es->cursor, es->cursor + argcnt);
+			for (cur = es->cursor; cur < es->linelen; cur++)
+				if (!isu8cont(es->cbuf[cur]))
+					if (argcnt-- == 0)
+						break;
+			del_range(es->cursor, cur);
 			insert = INSERT;
 			break;
 
@@ -961,22 +986,25 @@
 			if (es->linelen == 0)
 				return -1;
 			modified = 1; hnum = hlast;
-			if (es->cursor + argcnt > es->linelen)
-				argcnt = es->linelen - es->cursor;
-			yank_range(es->cursor, es->cursor + argcnt);
-			del_range(es->cursor, es->cursor + argcnt);
+			for (cur = es->cursor; cur < es->linelen; cur++)
+				if (!isu8cont(es->cbuf[cur]))
+					if (argcnt-- == 0)
+						break;
+			yank_range(es->cursor, cur);
+			del_range(es->cursor, cur);
 			break;
 
 		case 'X':
-			if (es->cursor > 0) {
-				modified = 1; hnum = hlast;
-				if (es->cursor < argcnt)
-					argcnt = es->cursor;
-				yank_range(es->cursor - argcnt, es->cursor);
-				del_range(es->cursor - argcnt, es->cursor);
-				es->cursor -= argcnt;
-			} else
+			if (es->cursor == 0)
 				return -1;
+			modified = 1; hnum = hlast;
+			for (cur = es->cursor; cur > 0; cur--)
+				if (!isu8cont(es->cbuf[cur]))
+					if (argcnt-- == 0)
+						break;
+			yank_range(cur, es->cursor);
+			del_range(cur, es->cursor);
+			es->cursor = cur;
 			break;
 
 		case 'u':
@@ -1017,7 +1045,7 @@
 			    c1, srchpat)) < 0) {
 				if (c3) {
 					restore_cbuf();
-					refresh(0);
+					refresh_line(0);
 				}
 				return -1;
 			} else {
@@ -1067,7 +1095,7 @@
 				argcnt++;
 				p++;
 			}
-			if (putbuf(space, 1, 0) != 0)
+			if (putbuf(" ", 1, 0) != 0)
 				argcnt = -1;
 			else if (putbuf(sp, argcnt, 0) != 0)
 				argcnt = -1;
@@ -1082,18 +1110,20 @@
 
 		case '~': {
 			char	*p;
+			unsigned char c;
 			int	i;
 
 			if (es->linelen == 0)
 				return -1;
 			for (i = 0; i < argcnt; i++) {
 				p = &es->cbuf[es->cursor];
-				if (islower((unsigned char)*p)) {
+				c = (unsigned char)*p;
+				if (islower(c)) {
 					modified = 1; hnum = hlast;
-					*p = toupper(*p);
-				} else if (isupper((unsigned char)*p)) {
+					*p = toupper(c);
+				} else if (isupper(c)) {
 					modified = 1; hnum = hlast;
-					*p = tolower(*p);
+					*p = tolower(c);
 				}
 				if (es->cursor < es->linelen - 1)
 					es->cursor++;
@@ -1111,33 +1141,35 @@
 		    }
 
 		case '=':			/* at&t ksh */
-		case Ctrl('e'):			/* Nonstandard vi/ksh */
-			print_expansions(es, 1);
+		case CTRL('e'):			/* Nonstandard vi/ksh */
+			print_expansions(es);
 			break;
 
 
-		case Ctrl('i'):			/* Nonstandard vi/ksh */
+		case CTRL('i'):			/* Nonstandard vi/ksh */
 			if (!Flag(FVITABCOMPLETE))
 				return -1;
 			complete_word(1, argcnt);
 			break;
 
-		case Ctrl('['):			/* some annoying at&t ksh's */
+		case CTRL('['):			/* some annoying at&t ksh's */
 			if (!Flag(FVIESCCOMPLETE))
 				return -1;
 		case '\\':			/* at&t ksh */
-		case Ctrl('f'):			/* Nonstandard vi/ksh */
+		case CTRL('f'):			/* Nonstandard vi/ksh */
 			complete_word(1, argcnt);
 			break;
 
 
 		case '*':			/* at&t ksh */
-		case Ctrl('x'):			/* Nonstandard vi/ksh */
+		case CTRL('x'):			/* Nonstandard vi/ksh */
 			expand_word(1);
 			break;
 		}
-		if (insert == 0 && es->cursor != 0 && es->cursor >= es->linelen)
-			es->cursor--;
+		if (insert == 0 && es->cursor >= es->linelen)
+			while (es->cursor > 0)
+				if (!isu8cont(es->cbuf[--es->cursor]))
+					break;
 	}
 	return 0;
 }
@@ -1151,31 +1183,20 @@
 	switch (*cmd) {
 
 	case 'b':
-		if (!sub && es->cursor == 0)
-			return -1;
-		ncursor = backword(argcnt);
-		break;
-
 	case 'B':
 		if (!sub && es->cursor == 0)
 			return -1;
-		ncursor = Backword(argcnt);
+		ncursor = (*cmd == 'b' ? backword : Backword)(argcnt);
 		break;
 
 	case 'e':
-		if (!sub && es->cursor + 1 >= es->linelen)
-			return -1;
-		ncursor = endword(argcnt);
-		if (sub && ncursor < es->linelen)
-			ncursor++;
-		break;
-
 	case 'E':
 		if (!sub && es->cursor + 1 >= es->linelen)
 			return -1;
-		ncursor = Endword(argcnt);
-		if (sub && ncursor < es->linelen)
-			ncursor++;
+		ncursor = (*cmd == 'e' ? endword : Endword)(argcnt);
+		if (!sub)
+			while (isu8cont((unsigned char)es->cbuf[--ncursor]))
+				continue;
 		break;
 
 	case 'f':
@@ -1201,35 +1222,30 @@
 		break;
 
 	case 'h':
-	case Ctrl('h'):
+	case CTRL('h'):
 		if (!sub && es->cursor == 0)
 			return -1;
-		ncursor = es->cursor - argcnt;
-		if (ncursor < 0)
-			ncursor = 0;
+		for (ncursor = es->cursor; ncursor > 0; ncursor--)
+			if (!isu8cont(es->cbuf[ncursor]))
+				if (argcnt-- == 0)
+					break;
 		break;
 
 	case ' ':
 	case 'l':
 		if (!sub && es->cursor + 1 >= es->linelen)
 			return -1;
-		if (es->linelen != 0) {
-			ncursor = es->cursor + argcnt;
-			if (ncursor > es->linelen)
-				ncursor = es->linelen;
-		}
+		for (ncursor = es->cursor; ncursor < es->linelen; ncursor++)
+			if (!isu8cont(es->cbuf[ncursor]))
+				if (argcnt-- == 0)
+					break;
 		break;
 
 	case 'w':
-		if (!sub && es->cursor + 1 >= es->linelen)
-			return -1;
-		ncursor = forwword(argcnt);
-		break;
-
 	case 'W':
 		if (!sub && es->cursor + 1 >= es->linelen)
 			return -1;
-		ncursor = Forwword(argcnt);
+		ncursor = (*cmd == 'w' ? forwword : Forwword)(argcnt);
 		break;
 
 	case '0':
@@ -1249,13 +1265,12 @@
 			ncursor = es->linelen;
 		if (ncursor)
 			ncursor--;
+		while (isu8cont(es->cbuf[ncursor]))
+			ncursor--;
 		break;
 
 	case '$':
-		if (es->linelen != 0)
-			ncursor = es->linelen;
-		else
-			ncursor = 0;
+		ncursor = es->linelen;
 		break;
 
 	case '%':
@@ -1297,7 +1312,8 @@
 		if (putbuf(ibuf, inslen, insert==REPLACE) != 0)
 			return -1;
 	if (es->cursor > 0)
-		es->cursor--;
+		while (isu8cont(es->cbuf[--es->cursor]))
+			continue;
 	insert = 0;
 	return 0;
 }
@@ -1342,17 +1358,16 @@
  *	Non user interface editor routines below here
  */
 
-static int	cur_col;		/* current column on line */
-static int	pwidth;			/* width of prompt */
+static int	cur_col;		/* current display column */
+static int	pwidth;			/* display columns needed for prompt */
 static int	prompt_trunc;		/* how much of prompt to truncate */
 static int	prompt_skip;		/* how much of prompt to skip */
-static int	winwidth;		/* width of window */
-static char	*wbuf[2];		/* window buffers */
+static int	winwidth;		/* available column positions */
+static char	*wbuf[2];		/* current & previous window buffer */
 static int	wbuf_len;		/* length of window buffers (x_cols-3)*/
-static int	win;			/* window buffer in use */
+static int	win;			/* number of window buffer in use */
 static char	morec;			/* more character at right of window */
-static int	lastref;		/* argument to last refresh() */
-static char	holdbuf[CMDLEN];	/* place to hold last edit buffer */
+static char	holdbuf[LINE];		/* place to hold last edit buffer */
 static int	holdlen;		/* length of holdbuf */
 
 static void
@@ -1377,7 +1392,7 @@
 {
 	struct edstate *new;
 
-	new = (struct edstate *)alloc(sizeof(struct edstate), APERM);
+	new = alloc(sizeof(struct edstate), APERM);
 	new->cbuf = alloc(old->cbufsize, APERM);
 	memcpy(new->cbuf, old->cbuf, old->linelen);
 	new->cbufsize = old->cbufsize;
@@ -1401,7 +1416,7 @@
 free_edstate(struct edstate *old)
 {
 	afree(old->cbuf, APERM);
-	afree((char *)old, APERM);
+	afree(old, APERM);
 }
 
 
@@ -1439,7 +1454,6 @@
 	winwidth = x_cols - pwidth - 3;
 	win = 0;
 	morec = ' ';
-	lastref = 1;
 	holdlen = 0;
 }
 
@@ -1510,80 +1524,100 @@
 	return ncursor;
 }
 
+/* Move right one character, and then to the beginning of the next word. */
 static int
 forwword(int argcnt)
 {
-	int	ncursor;
+	int ncursor, skip_space, want_letnum;
+	unsigned char uc;
 
 	ncursor = es->cursor;
 	while (ncursor < es->linelen && argcnt--) {
-		if (is_wordch(es->cbuf[ncursor]))
-			while (is_wordch(es->cbuf[ncursor]) &&
-			    ncursor < es->linelen)
-				ncursor++;
-		else if (!isspace((unsigned char)es->cbuf[ncursor]))
-			while (!is_wordch(es->cbuf[ncursor]) &&
-			    !isspace((unsigned char)es->cbuf[ncursor]) &&
-			    ncursor < es->linelen)
-				ncursor++;
-		while (isspace((unsigned char)es->cbuf[ncursor]) &&
-		    ncursor < es->linelen)
-			ncursor++;
+		skip_space = 0;
+		want_letnum = -1;
+		ncursor--;
+		while (++ncursor < es->linelen) {
+			uc = es->cbuf[ncursor];
+			if (isspace(uc)) {
+				skip_space = 1;
+				continue;
+			} else if (skip_space)
+				break;
+			if (uc & 0x80)
+				continue;
+			if (want_letnum == -1)
+				want_letnum = letnum(uc);
+			else if (want_letnum != letnum(uc))
+				break;
+		}
 	}
 	return ncursor;
 }
 
+/* Move left one character, and then to the beginning of the word. */
 static int
 backword(int argcnt)
 {
-	int	ncursor;
+	int ncursor, skip_space, want_letnum;
+	unsigned char uc;
 
 	ncursor = es->cursor;
 	while (ncursor > 0 && argcnt--) {
-		while (--ncursor > 0 && isspace((unsigned char)es->cbuf[ncursor]))
-			;
-		if (ncursor > 0) {
-			if (is_wordch(es->cbuf[ncursor]))
-				while (--ncursor >= 0 &&
-				    is_wordch(es->cbuf[ncursor]))
-					;
-			else
-				while (--ncursor >= 0 &&
-				    !is_wordch(es->cbuf[ncursor]) &&
-				    !isspace((unsigned char)es->cbuf[ncursor]))
-					;
-			ncursor++;
+		skip_space = 1;
+		want_letnum = -1;
+		while (ncursor-- > 0) {
+			uc = es->cbuf[ncursor];
+			if (isspace(uc)) {
+				if (skip_space)
+					continue;
+				else
+					break;
+			}
+			skip_space = 0;
+			if (uc & 0x80)
+				continue;
+			if (want_letnum == -1)
+				want_letnum = letnum(uc);
+			else if (want_letnum != letnum(uc))
+				break;
 		}
+		ncursor++;
 	}
 	return ncursor;
 }
 
+/* Move right one character, and then to the byte after the word. */
 static int
 endword(int argcnt)
 {
-	int	ncursor;
+	int ncursor, skip_space, want_letnum;
+	unsigned char uc;
 
 	ncursor = es->cursor;
 	while (ncursor < es->linelen && argcnt--) {
-		while (++ncursor < es->linelen - 1 &&
-		    isspace((unsigned char)es->cbuf[ncursor]))
-			;
-		if (ncursor < es->linelen - 1) {
-			if (is_wordch(es->cbuf[ncursor]))
-				while (++ncursor < es->linelen &&
-				    is_wordch(es->cbuf[ncursor]))
-					;
-			else
-				while (++ncursor < es->linelen &&
-				    !is_wordch(es->cbuf[ncursor]) &&
-				    !isspace((unsigned char)es->cbuf[ncursor]))
-					;
-			ncursor--;
+		skip_space = 1;
+		want_letnum = -1;
+		while (++ncursor < es->linelen) {
+			uc = es->cbuf[ncursor];
+			if (isspace(uc)) {
+				if (skip_space)
+					continue;
+				else
+					break;
+			}
+			skip_space = 0;
+			if (uc & 0x80)
+				continue;
+			if (want_letnum == -1)
+				want_letnum = letnum(uc);
+			else if (want_letnum != letnum(uc))
+				break;
 		}
 	}
 	return ncursor;
 }
 
+/* Move right one character, and then to the beginning of the next big word. */
 static int
 Forwword(int argcnt)
 {
@@ -1601,6 +1635,7 @@
 	return ncursor;
 }
 
+/* Move left one character, and then to the beginning of the big word. */
 static int
 Backword(int argcnt)
 {
@@ -1619,22 +1654,20 @@
 	return ncursor;
 }
 
+/* Move right one character, and then to the byte after the big word. */
 static int
 Endword(int argcnt)
 {
 	int	ncursor;
 
 	ncursor = es->cursor;
-	while (ncursor < es->linelen - 1 && argcnt--) {
-		while (++ncursor < es->linelen - 1 &&
+	while (ncursor < es->linelen && argcnt--) {
+		while (++ncursor < es->linelen &&
 		    isspace((unsigned char)es->cbuf[ncursor]))
 			;
-		if (ncursor < es->linelen - 1) {
-			while (++ncursor < es->linelen &&
-			    !isspace((unsigned char)es->cbuf[ncursor]))
-				;
-			ncursor--;
-		}
+		while (ncursor < es->linelen &&
+		    !isspace((unsigned char)es->cbuf[ncursor]))
+			ncursor++;
 	}
 	return ncursor;
 }
@@ -1653,7 +1686,7 @@
 	}
 	(void) histnum(n);
 	if ((hptr = *histpos()) == NULL) {
-		internal_errorf(0, "grabhist: bad history array");
+//		internal_warningf("%s: bad history array", __func__);
 		return -1;
 	}
 	if (save)
@@ -1701,25 +1734,36 @@
 }
 
 static void
-redraw_line(int newline)
+do_clear_screen(void)
+{
+	int neednl = 1;
+
+#ifndef SMALL
+	if (cur_term != NULL && clear_screen != NULL) {
+		if (tputs(clear_screen, 1, x_putc) != ERR)
+			neednl = 0;
+	}
+#endif
+	/* Only print the full prompt if we cleared the screen. */
+	redraw_line(neednl, !neednl);
+}
+
+static void
+redraw_line(int neednl, int full)
 {
 	(void) memset(wbuf[win], ' ', wbuf_len);
-	if (newline) {
+	if (neednl) {
 		x_putc('\r');
 		x_putc('\n');
 	}
-	vi_pprompt(0);
+	vi_pprompt(full);
 	cur_col = pwidth;
 	morec = ' ';
 }
 
 static void
-refresh(int leftside)
+refresh_line(int leftside)
 {
-	if (leftside < 0)
-		leftside = lastref;
-	else
-		lastref = leftside;
 	if (outofwin())
 		rewindow();
 	display(wbuf[1 - win], wbuf[win], leftside);
@@ -1766,24 +1810,38 @@
 	es->winleft = holdcur1;
 }
 
+/* Printing the byte ch at display column col moves to which column? */
 static int
 newcol(int ch, int col)
 {
 	if (ch == '\t')
 		return (col | 7) + 1;
+	if (isu8cont(ch))
+		return col;
 	return col + char_len(ch);
 }
 
+/* Display wb1 assuming that wb2 is currently displayed. */
 static void
 display(char *wb1, char *wb2, int leftside)
 {
+	char	*twb1;	/* pointer into the buffer to display */
+	char	*twb2;	/* pointer into the previous display buffer */
+	static int lastb = -1; /* last byte# written from wb1, if UTF-8 */
+	int	 cur;	/* byte# in the main command line buffer */
+	int	 col;	/* display column loop variable */
+	int	 ncol;	/* display column of the cursor */
+	int	 cnt;	/* remaining display columns to fill */
+	int	 moreright;
+	char	 mc;	/* new "more character" at the right of window */
 	unsigned char ch;
-	char	*twb1, *twb2, mc;
-	int	cur, col, cnt;
-	int	ncol = 0;
-	int	moreright;
 
-	col = 0;
+	/*
+	 * Fill the current display buffer with data from cbuf.
+	 * In this first loop, col does not include the prompt.
+	 */
+
+	ncol = col = 0;
 	cur = es->winleft;
 	moreright = 0;
 	twb1 = wb1;
@@ -1812,7 +1870,8 @@
 					}
 				} else {
 					*twb1++ = ch;
-					col++;
+					if (!isu8cont(ch))
+						col++;
 				}
 			}
 		}
@@ -1822,6 +1881,9 @@
 	}
 	if (cur == es->cursor)
 		ncol = col + pwidth;
+
+	/* Pad the current display buffer to the right margin. */
+
 	if (col < winwidth) {
 		while (col < winwidth) {
 			*twb1++ = ' ';
@@ -1831,21 +1893,62 @@
 		moreright++;
 	*twb1 = ' ';
 
+	/*
+	 * Update the terminal display with data from wb1.
+	 * In this final loop, col includes the prompt.
+	 */
+
 	col = pwidth;
 	cnt = winwidth;
-	twb1 = wb1;
-	twb2 = wb2;
-	while (cnt--) {
+	for (twb1 = wb1, twb2 = wb2; cnt; twb1++, twb2++) {
 		if (*twb1 != *twb2) {
+
+			/*
+			 * When a byte changes in the middle of a UTF-8
+			 * character, back up to the start byte, unless
+			 * the previous byte was the last one written.
+			 */
+
+			if (col > 0 && isu8cont(*twb1)) {
+				col--;
+				if (lastb >= 0 && twb1 == wb1 + lastb + 1)
+					cur_col = col;
+				else while (twb1 > wb1 && isu8cont(*twb1)) {
+					twb1--;
+					twb2--;
+				}
+			}
+
 			if (cur_col != col)
 				ed_mov_opt(col, wb1);
+
+			/*
+			 * Always write complete characters, and
+			 * advance all pointers accordingly.
+			 */
+
 			x_putc(*twb1);
+			while (isu8cont(twb1[1])) {
+				x_putc(*++twb1);
+				twb2++;
+			}
+			lastb = *twb1 & 0x80 ? twb1 - wb1 : -1;
 			cur_col++;
-		}
-		twb1++;
-		twb2++;
+		} else if (isu8cont(*twb1))
+			continue;
+
+		/*
+		 * For changed continuation bytes, we backed up.
+		 * For unchanged ones, we jumped to the next byte.
+		 * So, getting here, we had a real column.
+		 */
+
 		col++;
+		cnt--;
 	}
+
+	/* Update the "more character". */
+
 	if (es->winleft > 0 && moreright)
 		/* POSIX says to use * for this but that is a globbing
 		 * character and may confuse people; + is more innocuous
@@ -1862,31 +1965,52 @@
 		x_putc(mc);
 		cur_col++;
 		morec = mc;
+		lastb = -1;
 	}
-	if (cur_col != ncol)
+
+	/* Move the cursor to its new position. */
+
+	if (cur_col != ncol) {
 		ed_mov_opt(ncol, wb1);
+		lastb = -1;
+	}
 }
 
+/* Move the display cursor to display column number col. */
 static void
 ed_mov_opt(int col, char *wb)
 {
-	if (col < cur_col) {
-		if (col + 1 < cur_col - col) {
+	int ci;
+
+	/* The cursor is already at the right place. */
+
+	if (cur_col == col)
+		return;
+
+	/* The cursor is too far right. */
+
+	if (cur_col > col) {
+		if (cur_col > 2 * col + 1) {
+			/* Much too far right, redraw from scratch. */
 			x_putc('\r');
 			vi_pprompt(0);
 			cur_col = pwidth;
-			while (cur_col++ < col)
-				x_putc(*wb++);
 		} else {
-			while (cur_col-- > col)
+			/* Slightly too far right, back up. */
+			do {
 				x_putc('\b');
+			} while (--cur_col > col);
+			return;
 		}
-	} else {
-		wb = &wb[cur_col - pwidth];
-		while (cur_col++ < col)
-			x_putc(*wb++);
 	}
-	cur_col = col;
+
+	/* Advance the cursor. */
+
+	for (ci = pwidth; ci < col || isu8cont(*wb);
+	     ci = newcol((unsigned char)*wb++, ci))
+		if (ci > cur_col || (ci == cur_col && !isu8cont(*wb)))
+			x_putc(*wb);
+	cur_col = ci;
 }
 
 
@@ -1904,18 +2028,18 @@
 	/* Undo previous expansion */
 	if (command == 0 && expanded == EXPAND && buf) {
 		restore_edstate(es, buf);
-		buf = 0;
+		buf = NULL;
 		expanded = NONE;
 		return 0;
 	}
 	if (buf) {
 		free_edstate(buf);
-		buf = 0;
+		buf = NULL;
 	}
 
 	nwords = x_cf_glob(XCF_COMMAND_FILE|XCF_FULLPATH,
 	    es->cbuf, es->linelen, es->cursor,
-	    &start, &end, &words, (int *) 0);
+	    &start, &end, &words, NULL);
 	if (nwords == 0) {
 		vi_error();
 		return -1;
@@ -1930,7 +2054,7 @@
 			rval = -1;
 			break;
 		}
-		if (++i < nwords && putbuf(space, 1, 0) != 0) {
+		if (++i < nwords && putbuf(" ", 1, 0) != 0) {
 			rval = -1;
 			break;
 		}
@@ -1941,7 +2065,7 @@
 	modified = 1; hnum = hlast;
 	insert = INSERT;
 	lastac = 0;
-	refresh(0);
+	refresh_line(0);
 	return rval;
 }
 
@@ -1960,19 +2084,19 @@
 
 	/* Undo previous completion */
 	if (command == 0 && expanded == COMPLETE && buf) {
-		print_expansions(buf, 0);
+		print_expansions(buf);
 		expanded = PRINT;
 		return 0;
 	}
 	if (command == 0 && expanded == PRINT && buf) {
 		restore_edstate(es, buf);
-		buf = 0;
+		buf = NULL;
 		expanded = NONE;
 		return 0;
 	}
 	if (buf) {
 		free_edstate(buf);
-		buf = 0;
+		buf = NULL;
 	}
 
 	/* XCF_FULLPATH for count 'cause the menu printed by print_expansions()
@@ -1993,7 +2117,7 @@
 			vi_error();
 			x_print_expansions(nwords, words, is_command);
 			x_free_words(nwords, words);
-			redraw_line(0);
+			redraw_line(0, 0);
 			return -1;
 		}
 		/*
@@ -2001,12 +2125,12 @@
 		 */
 		if (is_command) {
 			match = words[count] +
-			    x_basename(words[count], (char *) 0);
+			    x_basename(words[count], NULL);
 			/* If more than one possible match, use full path */
 			for (i = 0; i < nwords; i++)
 				if (i != count &&
 				    strcmp(words[i] + x_basename(words[i],
-				    (char *) 0), match) == 0) {
+				    NULL), match) == 0) {
 					match = words[count];
 					break;
 				}
@@ -2038,20 +2162,20 @@
 
 		/* If not a directory, add a space to the end... */
 		if (match_len > 0 && match[match_len - 1] != '/')
-			rval = putbuf(space, 1, 0);
+			rval = putbuf(" ", 1, 0);
 	}
 	x_free_words(nwords, words);
 
 	modified = 1; hnum = hlast;
 	insert = INSERT;
 	lastac = 0;	 /* prevent this from being redone... */
-	refresh(0);
+	refresh_line(0);
 
 	return rval;
 }
 
 static int
-print_expansions(struct edstate *e, int command)
+print_expansions(struct edstate *e)
 {
 	int nwords;
 	int start, end;
@@ -2067,11 +2191,15 @@
 	}
 	x_print_expansions(nwords, words, is_command);
 	x_free_words(nwords, words);
-	redraw_line(0);
+	redraw_line(0, 0);
 	return 0;
 }
 
-/* How long is char when displayed (not counting tabs) */
+/*
+ * The number of bytes needed to encode byte c.
+ * Control bytes get "M-" or "^" prepended.
+ * This function does not handle tabs.
+ */
 static int
 char_len(int c)
 {
@@ -2125,4 +2253,9 @@
 	}
 }
 
+static int
+isu8cont(unsigned char c)
+{
+	return !Flag(FVISHOW8) && (c & (0x80 | 0x40)) == 0x80;
+}
 #endif	/* VI */
